### 文件
**ls:查看当前目录下所有内容,全名list**
```bash
文件属性： 
      -：普通文件 
      d：目录文件 
      b：块设备 
      c：字符设备文件 
      l：符号连接文件 
      p:命令管道 
      s：套接字文件 
     
文件权限： 
      9位数字，每3位一组 ，r（可读）、w（可写）、x（可执行）
      文件硬链接次数 
      文件所属主（owner） 
      文件的属组（group） 
      文件大小（size），单位默认是字节 
   
文件时间戳：
      access time：访问时间
      modify time：修改时间
      change time：改变的时间，如修改文件属性或文件名

ls常用选项： 
      -l：显示文件属性，ls -l=ll 
      -h：做相应的单位转换显示 
      -a：显示所有文件 
      -A：显示.和..以为的所有文件 
      -d：显示目录自身属性 
      -i：显示文件的缩影接点号码（index node ，inode） 
      -r：逆序显示文件列表 
      -R：递归显示文件
```
---------------------------------------------------------------------
**cd:切换目录,全名change directory**
```bash
常用选项：
      cd：切回家目录
      cd ~：进入用户的家目录
      cd -：在当前目录和前一次所在的目录来回切换（经常使用）
      cd ..:切换至其父目录
```
---------------------------------------------------------------------
**pwd:打印当前目录，全名print working directory**

---------------------------------------------------------------------
** basename：显示一个目录的基名**

---------------------------------------------------------------------
**mkdir:创建目录，全名make directory**
```bash
常用选项：
     -p:递归创建目录       
      Eg>1.mkdir -p /home/xxf/test 
        >2.mkdir -p /home/xxf/{x/y,a/b}     
     -v:打印细节     
     -m:创建时，设置权限。包括属主属组其他  
      Eg>mkdir -m 777 -p /home/xxf/test
```
---------------------------------------------------------------------
**rmdir:删除目录，全名remove empty directories**
```bash
常用选项：
     -p：删除某目录后，如果其父目录为空，则一并删除之         
     -v:打印细节     
```
---------------------------------------------------------------------
**tree:查看目录树**
```bash
常用选项：
     -a:显示所有文件和目录
     -A:使用ASNI绘图字符显示树状图而非以ASCII字符组合
     -C:在文件和目录清单加上色彩，便于区分各种类型
     -d:显示目录名称而非内容
     -D:列出文件或目录的更改时间
     -f:在每个文件或目录之前，显示完整的相对路径名称
     -F:在执行文件，目录，Socket，符号连接，管道名称名称，各自加上"*","/","=","@","|"号
     -g:列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码
     -i:不以阶梯状列出文件或目录名称
     -I:<范本样式> 不显示符合范本样式的文件或目录名称
     -l:如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录
     -n:不在文件和目录清单加上色彩
     -N:直接列出文件和目录名称，包括控制字符
     -p:列出权限标示
     -h:同时打印文件和目录大小
      Eg>1.tree -h dir
     -P:<范本样式> 只显示符合范本样式的文件或目录名称
      Eg>1.tree dir -P "*.sh"
     -H和-o：将内容保存至指定路径下的指定格式
      Eg>1.tree dir -H http://localhost -o out.html
     -q:用"?"号取代控制字符，列出文件和目录名称
     -s:列出文件或目录大小
     -t:用文件和目录的更改时间排序
     -u:列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码
     -x:将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外
```
---------------------------------------------------------------------
**install：复制文件及设置属性​**
```bash
复制模式：
    单源复制：
       install [OPTION]... [-T] SOURCE DEST
    多源复制：
       install [OPTION]... SOURCE... DIRECTORY
       install [OPTION]... -t DIRECTORY SOURCE...
常用选项：
    -d:表示创建目录
      Eg>1.install -d dir1 dir2 ...
    -m, --mode=MODE：设定目标文件权限，默认为755
    -o, --owner=OWNER：设定目标文件属主
    -g, --group=GROUP：设定目标文件属组
```
---------------------------------------------------------------------
**mktemp：创建临时文件或目录**

mktemp会将创建的临时文件名直接返回，因此，可直接通过命令引用保存起来
```bash
常用选项：
    -d：创建临时目录
```
---------------------------------------------------------------------
**ln：创建链接**

硬件连接： 

    1、只能对文件创建，不能应用于目录，文件的硬链接次数为2 
    
    2、不能夸文件系统 
       
    3、创建硬链接会增加文件被连接的次数 
       
符号连接： 
       
    1、可应用于目录 
       
    2、可以跨文件系统 
       
    3、不会增加被连接文件的连接次数 
       
       4、其大小为指定的路径所包含的字符个数 
```bash
常用选项：
    ln SRC DEST：创建硬链接 
    -s：创建软连接 
    -i：显示文件的inode号 
    -v：显示执行详情
       
```
---------------------------------------------------------------------
**​cat：文件文本查看工具，全名concatenate**
```bash
常用选项：
     -s：压缩连续的空白行至一行
     -n 显示行号，类似于nl
      Eg>1.cat -s -n compare_and_test.sh
         #使用tr移除换行符，将连续多个\n压缩成单个
        >2.cat compare_and_test.sh | tr -s '\n'
     -T:#将制表符显示为^|，在py语言中尤其有用,区分table符号还是空格
       Eg>1.cat -T test.py
     -E:打印文件每行的结尾符$
```
---------------------------------------------------------------------
**fuser：验证进行正在使用的文件或套接字**
```bash
常用选项：
    -v：查看某文件上正在使用的进程 
    -k：把正在访问的进程给kill了 
    -km：把挂载点上的进程都关闭掉 
```
---------------------------------------------------------------------
**​dd：生成任意大小的文件**
```bash
常用选项：
    count：表示个数
    bs：表示大小
    if：输入类型，默认为stdin
    of：输出类型，默认为stdout
实例脚本：
    1.生成一个100k的测试文件
      #if如果不指定该参数，默认情况下dd会从stdin读取输入，同理如果不指定of，那么dd会将stdout作为默认输出
     Eg>dd if=/dev/zero bs=100k count=1 of=data.file
```
---------------------------------------------------------------------
**​tac：文件文本查看工具，反向**
```bash
常用选项：
     -b：打印不包括文件名在内的文件类型信息
      Eg>1.file -b $1
实例脚本：
     Eg>1.生成文件统计信息
     if [ $# -ne 1 ];
     then
        echo $0 basepath;
        echo
     fi
     path=$1
     Eg>2.数组操作
     declare -A statarray;
     while read line;
     do
     	ftype=`file -b $line`;
     	let statarray["$ftype"]++;
     done< <(find $path -type f -print)
     #返回数组的索引列表
     echo  "-------File type and counts--------"
     for ftype in "${!statarray[@]}"
     do 
     	echo $ftype:${statarray["$ftype"]}
     done
```
---------------------------------------------------------------------
**​file：查看文件类型**
```bash
常用选项：
     -n：显示行号，类似于nl
     -E:打印文件每行的结尾符$
```
---------------------------------------------------------------------
**wc：统计单词长度**
```bash
常用选项：
    -l：统计行数
     Eg>wc -l file.txt

    -c：统计字符数
     Eg>wc -c file.txt

    -w：统计单词数
     Eg>wc -w file.txt

    -L:打印最长的行
     Eg>wc -L file.txt
```
---------------------------------------------------------------------
**cut:分割文件**
```bash
常用选项：
    -d CHAR：以指定的字符为分隔符
	-f FIELDS：挑选出的字段
	    #：指定的单个字段
	     Eg>cut -f1 -d"\t" data.txt,表示表示显示第1个字段 
		#-#：连续的多个字段
		 Eg>cut -f1-3 -d"\t" data.txt,表示表示显示第1个到第3个字段 
		#,#：离散的多个字段
		 Eg>cut -f1,3 -d"\t" data.txt,表示表示显示第1个和第3个字段 
	--complement：类似反选，打印除第几行外其他的行
	  Eg>cut -f3 --complement file.txt,表示打印除第3行以外的
	--output-delimter：输出分隔符
	  Eg>cut file.txt -c/-b-3 --output-delimter "," 
```
---------------------------------------------------------------------
**sort：文本排序，仅仅是对显示文件的排序，而不影响源文件的顺序，是根据ASSII码的字符升序来排列**
```bash
常用选项：
    -n：基于数值大小而非字符进行排序
	-t CHAR：指定分隔符
	-k #：指定排序的列
	-C：判断一个文件是否排过序
	-r：逆序排序
	-o：输出文件
	  Eg>sort a.txt -o a.txt
	-f：忽略字符大小写
	-u：重复行只保留一份，这里的复复行：连续且相同
    -M：按照月份来进行排序
    -b：用于忽略文件中的前导空白字符
    -d：以字典方式进行排序
    -m：将排过序的文件合并
    -z：去除结尾符
    
实例脚本：
    1.判断是否排过序
      sort -C file.txt;
      if [ $? -eq 0 ];
     then
     	echo Sorted
     else
    	echo Unsorted
     fi
    2.排序过的文件进行排序，而且合并后不需要在进行排序
      sort -m st1 st2

    3.按第一列反序排序
     #-k,指定排序的列,可结合-nr
     #-n表示按照数字，-r表示反序，1表示列的索引
      sort -nrk 1 data.txt

    4.支持只选用键的某个范围的字符来排序
      sort -nk 2,3 data.txt

    5.使得sort的输出与以\0作为参数终止符的xargs命令相兼容
      sort -z data.txt | xargs -0

    6.忽略不必要的字符
      sort -bd unsort.txt

    7.-u重复行只打印一次
     sort  data.txt | uniq
     等价于：sort -u data.txt
```
---------------------------------------------------------------------
**uniq：报告或移除重复的行**
```bash
常用选项：
    -u:只显示唯一行
      Eg>uniq -u unsorted.txt

    -c:统计各行在文件出现的次数
      Eg>sort data.txt | uniq -c

    -d:找出重复的行
      Eg>sort unsorted | uniq -d

    -z:使用\0作为字节终止符,结合xargs使用
      Eg>uniq -z file.txt
        >uniq -z file.txt | xargs -0 rm

实例脚本：
    1.统计每个字符出现的次数
     input="ahebhaaaa"
     #第一个sed：表示在每个字符后面追加一个换行符，使得每行只出现一个字符，确保我们能够进行sort排序
     #第二个sed：最后一个空行会被替换成字符+\n，因为会多出一个换行符在最后形成一个空行，使用这个命令对其进行删除
     OUPUT=`echo %input | sed 's/[^.]/&\n/g' | sed '/^$/d' | sort | uniq -c | tr -d ' \n'`
     echo $OUTPUT
```    

---------------------------------------------------------------------
**diff:查找文件差异并进行修补**
```bash
常用选项：
    -u：使用unfied机制，即显示要修改的行的上下文，默认为3行
      Eg>diff -u a.txt b.txt
    -R：表示在撤销修改时，不会提示用户选择y/n
    -N：将所有缺失的文件视为空文件
    -a：将所有文件视为文本文件
    -u：一体化输出
    -r：递归目录下所有文件
实例脚本：
    1.生成差异文件
     Eg>diff a.txt b.txt

```    
---------------------------------------------------------------------
**patch：向文件打补丁**
```bash
实例脚本：
    1.patch将变动应用于任一一个文件
     Eg>diff -u a.txt b.txt > diff.patch
        patch -p1 a.txt < diff.patch


```    
---------------------------------------------------------------------
**paste:合并文件**
```bash
常用选项：
    -d：设置新的定界符
实例脚本：
    1.按列进行合并，默认定界符为制表符，也可以使用-d明确指定
     Eg>paste a.txt b.txt
      Eg>paste a.txt b.txt -d ","

```    
---------------------------------------------------------------------
**comm：逐行比较两个排序过的文件**
```bash
实例脚本：
    1.求两个文件的相同和不同
     Eg>sort a.txt -o a.txt;
     sort b.txt -o b.txt;
     comm a.txt b.txt 
    #输出结果中，第一列为a.txt特有的，第二列为b.txt特有的，第三列为共有的，可以使用-1，-2，-3对相应列进行过滤
    2.只显示相同的列
     Eg>comm a.txt b.txt -1 -2
    3.打印不同的列-3
     Eg>comm a.txt b.txt -3
    4.去除格式化，合并两列不同的值
     Eg>comm a.txt b.txt -3 | sed 's/^\t//'
```    
---------------------------------------------------------------------
**split：分割文件**
```bash
常用选项：
    -b：指定每个数据的大小，单位可以为k/M/G/c/w
     Eg>split -b 10k data.file

    -d:表示分割的文件数字结尾,默认是字母
    -a:表示长度
     Eg>split -b 10k data.file -d -a 4
     为分割后的文件指定前缀
     Eg>split -b 10k data.file -d -a 4 prefix

    -l:不按照数据块大小来分，按照行数来进行分割
     Eg>split -l 10 data.file
```    
---------------------------------------------------------------------
**csplit:依据指定的条件和字符串匹配选项对文件进行分割**
```bash
常用选项：
    -s:表示静默
    -n:表示分割后文件名字后缀的数字个数
    -f:表示分割后的文件前缀
    -b:指定文件格式=前缀+后缀，server+%02d.log
     Eg>csplit server.log /SERVER/ -n 2 -s {*} -f server -b "%02d.log" ; rm server00.log
     
        
```    
---------------------------------------------------------------------
**根据扩展名切分文件**
```bash
实例脚本：
    1.根据扩展名进行切分文件名
     #${VAR%.*},#从左向右执行，表示删除#左边的通配符，非贪婪；##表示执行贪婪模式
    2.提取文件名扩展名
     file_jpg="sample.jpg"
     name=${file_jpg#.*}

    3.%提取文件名，%从右向左执行，删除%右侧的通配符，属于非贪婪操作,%%表示执行贪婪操作
     file_jpg="sample.jpg"
     name=${file_jpg%.*}
        
```    
---------------------------------------------------------------------
**test：测试文件**

需要注意：[]等价于test
```bash
常用选项：
    1.文件测试
        -f:如果给定的变量包含正常的文件路径或者文件名，则返回真
         Eg>[ -f $file_var ]
        -x:如果给定的变量包含的文件可执行，则返回为真
         Eg>[ -x $var ]
        -d:如果给定的变量包含的是目录。则返回为真
         Eg>[ -d $var ]
        -e:如果给定的变量包含的是文件，则返回为真
         Eg>[ -e $var ]
        -c:如果给定的变量包含的是一个字符设备文件的路径，则返回为真
         Eg>[ -c $var ]
        -b:如果给定的变量包含一个块设备文件的路径，则返回为真
         Eg>[ -b $var ]
        -w:如果给定的变量包含的文件可写，则返回为真
         Eg>[ -w $var ]
        -r:如果包含的文件可读，则返回为真
         Eg>[ -r $var ]
        -L:如果包含的文件是一个软连接，则返回为真
         Eg>[ -L $var ]
    2.字符串测试
        =:中间的=两边的空格不能去掉，否则就变成了赋值操作
         Eg>[[ $str1 = $str2 ]][[ $str1 == $str2 ]]
         Eg>[[ $str1 != $str2 ]][[ $str1 > $str2 ]]
         Eg>[[ $str1 < $str2 ]]
        -z:如果str1包含的是空字符串，则返回为真
         Eg>[[ -z $str1 ]]
        -n:如果str1包含的是非空字符串，则返回为真
         Eg>[[ -n $str1 ]]
    3.数值测试
        -eq:等于则为真
        -ne:不等于则为真
        -gt:大于则为真
        -ge:大于等于则为真
        -lt:小于则为真
        -le:小于等于则为真
实例脚本：
    1.测试字符串是否相等
     num1="xxf"
     num2="xxf"
     if test $num1 = $num2
     then
         echo '两个字符串相等!'
     else
         echo '两个字符串不相等!'
     fi
```    
---------------------------------------------------------------------
**​stat：查看文件状态**

---------------------------------------------------------------------
**​touch：修改文件**
```bash
常用选项：
     -c: 指定的文件路径不存在时不予创建；
     -a: 仅修改access time；
     -m：仅修改modify time；
      Eg>1.touch -a/-m filename
     -t+STAMP：加时间戳
     	[[CC]YY]MMDDhhmm[.ss]
     -d:指定日期
      Eg>1.touch -a/-m filename
实例脚本：
     1.批量生成空白文件
      for name in {0..100}.txt
      do 
      	touch $name
      done
     #上述{0..100}.txt其他写法
     test{0..100}.txt
```
---------------------------------------------------------------------
**cp：拷贝文件**
cp：文件复制，规则：只有最后一个为目标。复制一个文件到一个文件  或者 多个文件
    到一个目录！ 
      cp /etc/passwd /tmp/   复制到目录下并保存原文件名 
      cp /etc/passwd /tmp/test 看test是文件还是目录，目录：负责到目录内，文件则替换！
```bash
常用选项： 
      -r：递归复制目录 
      -i：交互式显示复制 
      -f：强制复制，覆盖 
      -p：保留源文件的属性，时间戳 
      -a：保留源文件的所有属性 
      -P：复制链接文件时保存为链接（默认是复制链接所指向的文件） 
      -d：复制时保持链接 
      -a：归档复制，常用与备份
```
---------------------------------------------------------------------
**scp：Linux之间复制文件和目录，文件是通过ssh加密通道进行传输的**
```bash
常用选项： 
      -r:递归复制
       Eg>1.scp -r /home user@remotehost:/path
      -p:在复制时保留文件的权限和模式
       Eg>1.scp -r -p /home user@remotehost:/path
```
---------------------------------------------------------------------
**rm：删除文件或目录**
```bash
常用选项： 
      -i：询问是否确定删除
      -f：强制删除
      -r: 递归删除，如删除目录时
```
---------------------------------------------------------------------
**mv：移动或重命名文件 **
```bash
常用形式： 
     mv SRC DEST：当SRC和DEST同目录时，表示重命名
实例脚本：
    1.批量重命名
     Eg>count=1;
        for img in *.jpg *.png
        do
        	new=img-%count.${img##*.}
        	mv "$img" "$new" 2> /dev/null

        	if [ $? -eq 0 ];then
        		echo "rename success"
        		let count++
        	fi
        done
```

---------------------------------------------------------------------
**rename：用字符串替换的方式批量改变文件名 **
```bash
实例脚本： 
    1.支持正则
     Eg>rename 's/ /_/g'
        rename *.jpg *.jpeg
        rename 'y/A-Z/a-z/' *
    2.结合find一起使用，将所有的mp3文件移动至tmp文件夹下
      Eg>find / -type f -name "*.mp3" -exec mv {} /tmp \;
    3.将文件名中所有的空格替换成_
      Eg>find / -type f -name "*.mp3" -exec rename 's/ /_/g' {}\;
```
---------------------------------------------------------------------
**​find：实时查找工具，通过遍历指定起始路径下文件系统层级结构完成文件查找**
```bash
常用选项：
    -regex:表示正则表达式
      Eg>find / -iregex "\(\.py|\.sh\)$"
    -path:使用通配符来匹配文件路径或者文件
    -name:使用给定的文件名来进行匹配
    -i：表示忽略大小写
    -o：表示或者，多条规律条件
      Eg>find / -iname "*.sh" -o -name "*.txt"
    !:表示取反
      Eg>find / ! -name "*.txt" 

    -maxdepth/-mindepth:递归多级查找
      Eg>递归打印当前以及下一级的目录中文件
         find / -maxdepth 2 -type f 
    -type:根据文件类型来进行查找.常见的如下：
       f:文件，d：目录，l：链接，c字符设备，b表示块设备，s表示套接字，p表示管道
      Eg>find / -type f/d/l/c/b/s/p
    
    根据文件时间来进行查找,常见如下：
        按天：
            atime:表示访问时间
            mtime表示最后一次修改的时间
            ctime表示文件元数据最后一次被修改的时间，默认单位为天
        按分钟
            amin:表示访问时间
            mmin:表示最后一次修改的时间
            cmin:表示文件元数据最后一次被修改的时间，默认单位为分钟
    +:表示大于
    -:表示小于
    啥都没有表示等于
     Eg>find / -atime/-mtime/-ctime +/-/7 
    -newer：表示用于比较时间戳的参考文件，比file.txt更新的文件
      Eg>find / -type f -newer file.txt 
    -size:文件大小进行搜索,k/M/G，w子（2个字节），b表示块，c表示字节
     Eg>find / -size +/-/10k
    -delete:删除匹配的行
      Eg>find / -type -f -name "*.txt" -delete
    -perm:根据权限来进行查找
      Eg>find / -type f -perm 644

    -user:根据用户来进行查找
      Eg>find / -type f -user xiaxuefei 
    
    -exec：实现更复杂的功能
    
    -print：输出至标准输出；默认的动作
    
	-ls：类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息
	-fls /PATH/TO/SOMEFILE：把查找到的所有文件的长格式信息保存至指定文件中；
	-ok COMMAND {} \; ：对查找到的每个文件执行由COMMAND表示的命令；每次操作都由用户进行确认
    -prune:使用过滤器
      Eg>find / -type f -name "*.sh" -prune 
实例脚本：
    1.chown修改属主数组
      对于每一个匹配的文件，{}会被替换成相应的文件名
      Eg>find / -type f -user root -exec chown xxf {}\;
    2.cat把所有*.c文件追加到一个文件中
      Eg>find / -type f -name "*.c" -exec cat {} \;>all_c_files.txt
    3.cp命令实现文件的复制
      Eg>find / -type f -mtime +10 -name "*.c" -exec cp {} OLD \;
    4.打印选中的文件
      Eg>find / -type f -name "*.txt" -exec printf "Text file:%s\n" {} \;
    5.查找/usr目录下不属于root, bin或hadoop的所有文件或目录
      Eg>find /usr -not \( -user root -o -user bin -o -user hadoop \) -ls
    
```
---------------------------------------------------------------------
**locate：依赖于事先构建好的索引库**

更新策略：

系统自动实现（周期性任务）；

手动更新数据库（updatedb）
```bash
常用选项：
    -b：只匹配路径中的基名；
	-c：统计出共有多少个符合条件的文件；
	-r：BRE

```
---------------------------------------------------------------------








### 命令帮助
**type：显示指定命令所属类型，命令分为内置和外部两种类型**
```bash
常用选项：
     type+command
```
---------------------------------------------------------------------
**whatis:输出作为参数的命令的简短描述**
```bash
常用选项：
     whatis+command
```
---------------------------------------------------------------------
**whereis:返回命令的路径，而且还会打印其对应的命令手册的位置和源代码的位置**
```bash
常用选项：
     whereis+command
     -b：仅搜索二进制程序路径
     -m：仅搜索使用手册文件路径
```
---------------------------------------------------------------------
**which:找出某个命令的位置**
```bash
常用选项：
     which+command
     --skip-alias：忽略别名
```
---------------------------------------------------------------------
**printenv：打印环境变量**

---------------------------------------------------------------------
**hash：查看最近命令命中次数,可参照history**
```bash
常用选项：
    ：列出
	-d COMMAND：删除
	-r：清空
```
---------------------------------------------------------------------
**history：查看命令历史，同Ctrl+R**
```bash
常用选项：
    -c: 清空命令历史
    -d offset：删除指定命令历史
    -r: 从文件读取命令历史至历史列表中
    -w：把历史列表中的命令追加至历史文件中
    history #：显示最近的#条命令

常用操作：
    !#：再一次执行历史列表中的第#条命令；
    !!：再一次执行上一条命令；
    !STRING：再一次执行命令历史列表中最近一个以STRING开头的命令； 
    ESC+.：上条指令，同!$
配置参数：
     HISTSIZE：shell进程可保留的命令历史的条数
     HISTFILE：持久保存命令历史的文件，见.bash_history
     HISTFILESIZE：命令历史文件的大小
     HISTCONTROL：命令输出方式
        =ignoredups：忽略重复的命令
        =ignorespace：忽略以空白字符开头的命令
        =ignoreboth：以上两者同时生效
```
---------------------------------------------------------------------
**alias：设置别名**
```bash
常用方式：
     alias NAME='COMMAND'：仅对当前shell有用
```
---------------------------------------------------------------------
**unalias：取消别名**
```bash
常用方式：
     unalias NAME
```
---------------------------------------------------------------------
**more：分屏显示，翻屏至文件尾部后自动退出**

---------------------------------------------------------------------
**less：分屏显示，显示文件信息，默认不退出显示，q即可退出**
```bash
常用选项：
     空格：向后翻一屏 
     b：向前翻一屏 
     ENTER：向后翻一行 
     k：向前翻一行 
     关键字查找 
       /KEYWORD：查找关键字
         n：下一个
         N：上一个         
```
---------------------------------------------------------------------
**head：查看前n行**
```bash
常用选项：
     -n：显示前n行，默认为10
```
---------------------------------------------------------------------
**tail：查看后n行**
```bash
常用选项：
    -n：显示后n行，默认为10
     Eg>1.tail -n x file.txt
    -x：打印前x行之外的所有行
     Eg>1.tail -n +x file.txt
    -f：动态输出,有新的内容会输出值屏幕
     Eg>1.tail -f file.txt
    --pid：监视某个进程
     Eg>1.pidnum=$(pidof xxx)
       >tail -f file.txt --pid $pidnum
```


### 文档
**info:查看命令在线文档**
```bash
常用选项：
     info+command
```
---------------------------------------------------------------------
**help:查看命令文档，指内部命令**
```bash
常用选项：
     help+command
```
---------------------------------------------------------------------
**man：查看外部命令的帮助文档，在man模式下**
```bash
常用选项：
     -M：到指定目录下查找命令手册并打开
     man+command

man命令打开手册以后的操作方法：
    翻屏：
       空格键：向文件尾翻一屏；
       b: 向文件首部翻一屏；
       Ctrl+d：向文件尾部翻半屏；
       Ctrl+u：向文件首部翻半屏；
       回车键：向文件尾部翻一行；
       k: 向文件首部翻一行；
       G：跳转至最后一行；
	    Eg>1.#G: 跳转至指定行；
	      >2.1G：跳转至文件首部；       
    文本搜索：
       /keyword：从文件首部向文件尾部依次查找；不区分字符大小写；
       ?keyword：从文件尾部向文件首部依次查找；
       注意：
           n: 与查找命令方向相同
           N: 与查找命令方向相反
    退出：
       q
```
---------------------------------------------------------------------
### 时间
在Linux中，系统启动时从硬件读取日期和时间信息；读取完成以后，就不再与硬件相关联；时间分为系统时钟和硬件时钟。
**date：系统时钟**
```bash
常用选项：
      %F、%T、%Y、%m、%d、%H、%M、%S、%s: 从1970年1月1号(unix元年)0点0分0秒到命令执行那一刻经过的秒数
       Eg>date +%Y
```
---------------------------------------------------------------------
**hwclock：修改硬件时间**
```bash
常用选项：
     -w：将系统时间修改为硬件时间，以系统时间为准
     -s：将硬件时间修改系统为时间，以硬件时间为准
     -r:显示硬件时间,同clock 
```
---------------------------------------------------------------------
**cal：日历**
```bash
常用选项：
     -m：显示月
     -y：显示年
```
---------------------------------------------------------------------

### 用户与组
**基本简介**
```bash
用户管理基础概念：
	用户类别：
		管理员（0）
		普通用户
		    系统用户组：1-499(CentOS6), 1-999(CentOS7)
			登录用户组：500-60000(CentOS6), 1000-60000(CentOS7)）
	组类别：
		组类别1：
			管理员组
			普通用户组
				系统组
				登录组

		组标识：GroupID, GID
			管理员组：0
				普通用户组：1-65635
					系统用户组：1-499(CentOS6), 1-999(CentOS7)
					登录用户组：500-60000(CentOS6), 1000-60000(CentOS7)	

		名称解析：groupname <--> gid
			解析库：/etc/group	

		组类别2：
			用户的基本组
			用户的附加组

		组类别3:
			私有组：组名同用户名，且只包含一个用户；
			公共组：组内包含了多个用户；
	认证信息：
			通过比对事先存储的，与登录时提供的信息是否一致；
			password：
				/etc/shadow
				/etc/gshadow
				
			密码的使用策略：
				1、使用随机密码；
				2、最短长度不要低于8位；
				3、应该使用大写字母、小写字母、数字和标点符号四类字符中至少三类；
				4、定期更换；

			加密算法：
				对称加密：加密和解密使用同一个密码；
				非对称加密：加密和解密使用的一对儿密钥；
					密钥对儿：
						公钥：public key
						私钥: private key
				单向加密：只能加密，不能解密；提取数据特征码；
					定长输出
					雪崩效应

				常见算法：
					md5: message digest, 128bits
					sha：secure hash algorithm, 160bits
					sha224
					sha256
					sha384
					sha512
					在计算之时加salt，添加的随机数
	数据库文件：
		/etc/passwd:用户的信息库
			格式：login:password:uid:gid:comment:home:shell
			 注释：
			   name: 用户名
			   password：可以是加密的密码，也可是占位符x；
			   UID：
			   GID：用户所属的主组的ID号；
			   GECOS：注释信息
			   directory：用户的家目录；
			   shell：用户的默认shell，登录时默认shell程序；
		/etc/shadow:用户密码
			格式：login:encrpted_password:...
			注释：
			   用户名:加密的密码:最近一次修改密码的时间:最短使用期限:最长使用期限:警告期段:过期期限:保留字段
		/etc/group:组的信息库
			格式：group:password:gid:user_list
            注释：
              user_list为该组的用户成员；以此组为附加组的用户的用户列表
		密码存储格式：单向加密，并借助于salt完成
```		


**who：查看正在运行的用户**
```bash
常用选项：
     -b:本次系统启动时间
     -r：运行级别
```
---------------------------------------------------------------------
 **w：查看登录的用户**
 
 ---------------------------------------------------------------------
 **whoami：显示当前用户**
 
---------------------------------------------------------------------
 **finger：查看当前用户信息**
 ```bash
 常用选项：
    ：表示查看当前用户
    finger +用户名：查看指定用户名信息
 ```
---------------------------------------------------------------------
**last：查看最后一次启动及其登录会话信息**
```bash
实例脚本：
    last reboot：最后重启时间
```
---------------------------------------------------------------------
**lastb：获取失败的用户登录会话信息**

---------------------------------------------------------------------
**users：查看当前登录的主机列表**

---------------------------------------------------------------------
**id：显示用户的真和有效ID**
```bash
常用选项：
    -u: 仅显示有效的UID
    -g: 仅显示用户的基本组ID;
    -G：仅显示用户所属的所有组的ID
    -n: 显示名字而非ID
```
---------------------------------------------------------------------
**su：切换用户，全名switch user**
```bash
常用选项：
    登录式切换：会通过读取目标用户的配置文件来重新初始化
	su - USERNAME
	su -l USERNAME
    非登录式切换：不会读取目标用户的配置文件进行初始化
	su USERNAME
    注意：管理员可无密码切换至其它任何用户
```
---------------------------------------------------------------------
**chage：更改用户密码过期信息**
```bash
常用选项：
     -d：最后一次修改时间 
     -E：过期时间 
     -I：非活动时间 
     -m：最短期限 
     -M：最长期限 
     -W：警告时间 
```
---------------------------------------------------------------------
**newgrp：临时切换指定的组为基本组**
```bash
常用选项：
     -: 会模拟用户重新登录以实现重新初始化其工作环境
```
---------------------------------------------------------------------
**gpasswd：修改组密码**

组密码文件：/etc/gshadow
```bash
常用选项：
     -a USERNAME：向组中添加用户
	 -d USERNAME：从组中移除用户
```
---------------------------------------------------------------------
**groupdel：删除组**

---------------------------------------------------------------------
**groupmod：修改组属性**

```bash
常用选项：
    -g GID：修改GID
	-n new_name：修改组名
```
---------------------------------------------------------------------
**groupadd：添加组**

```bash
常用选项：
    -g GID：指定GID；默认是上一个组的GID+1
	-r: 创建系统组
```
---------------------------------------------------------------------
**passwd：修改用户密码**

密码文件：/etc/shadow
```bash
常用选项：
     ：直接修改当前用户自己密码
	-l, -u：锁定和解锁用户；
	-d：清除用户密码串；
	-e DATE: 过期期限，日期；
	-i DAYS：非活动期限；
	-n DAYS：密码的最短使用期限；
	-x DAYS：密码的最长使用期限；
	-w DAYS：警告期限
	--stdin：从命令行输入新密码
	 Eg>echo "PASSWORD" | passwd --stdin USERNAME
实例脚本：
    1.从屏幕输入密码：
     echo -e "Enter password:"
     #禁止将输入输出到屏幕
     stty -echo
     read password
     #允许将输入输出至屏幕
     stty echo
     echo
     echo Password read.
```
---------------------------------------------------------------------
**userdel：删除用户**

```bash
常用选项：
     ：只删除用户，不删除家目录
	-r：删除用户时，一并删除其家目录
```
---------------------------------------------------------------------
**usermod：修改用户属性**

```bash
常用选项：
	-u, --uid UID：修改用户的ID为此处指定的新UID
	-g, --gid GROUP：修改用户所属的基本组
	-G, --groups GROUP1[,GROUP2,...[,GROUPN]]]：修改用户所属的附加组；原来的附加组会被覆盖
	-a, --append：与-G一同使用，用于为用户追加新的附加组；
	-c, --comment COMMENT：修改注释信息
	-d, --home HOME_DIR：修改用户的家目录；用户原有的文件不会被转移至新位置
	-m, --move-home：只能与-d选项一同使用，用于将原来的家目录移动为新的家目录
	-l, --login NEW_LOGIN：修改用户名
	-s, --shell SHELL：修改用户的默认shell
	-L, --lock：锁定用户密码；即在用户原来的密码字符串之前添加一个"!"
	-U, --unlock：解锁用户的密码
```
---------------------------------------------------------------------
**useradd：创建用户**

创建用户时的诸多默认设定配置文件：/etc/login.defs
```bash
常用选项：
	-u, --uid UID：指定UID
	-g, --gid GROUP：指定基本组ID，此组得事先存在
	-G, --groups GROUP1[,GROUP2,...[,GROUPN]]]：指明用户所属的附加组，多个组之间用逗号分隔
	-c, --comment COMMENT：指明注释信息
	-d, --home HOME_DIR：以指定的路径为用户的家目录；通过复制/etc/skel此目录并重命名实现；指定的家目录路径如果事先存在，则不会为用户复制环境配置文件
	-s, --shell SHELL：指定用户的默认shell，可用的所有shell列表存储在/etc/shells文件中
	-r, --system：创建系统用户
	-D：显示创建用户的默认配置，默认修改的文件位于：/etc/default/useradd
实例脚本：
    1.创建一个用户为xxf，全名为xiaxuefei，默认shell为xshell
      Eg>useradd -c “xiaxuefei” -s /bin/tcsh  xxf
```
---------------------------------------------------------------------

### 系统
**shutdown：关机或重启**
```bash
常用选项：
     -h:halt，关机，等价于poweroff、halt、systemctl poweroff
     -r：重启，等价于reboot
     -c：取消关机
      now：立即
      hh:mm：绝对时间，几点几时执行操作
       wall：提示消息
```
---------------------------------------------------------------------
**uptime：查看系统运行多久**
```bash
实例脚本：
    IP_LIST='192.168.147.1 192.168.147.2'
    USER='test'
    for ip in $IP_LIST;
    do 
    	utime=$(ssh $USER@$IP uptime | awk '{print $3}')
    	echo $IP uptime: $utime
    done
```
---------------------------------------------------------------------
**系统与CPU**
```bash
实例脚本：
    1.打印当前系统主机名
     hostname
     uname -n

    2.打印版本号、架构信息
     uname -a

    3.打印内核发型版本
     uname -r

    4.打印主机类型
     uname -m
     
    5.打印cpu相关信息
     cat /proc/cpuinfo

    6.打印内存相关信息
     cat /proc/meminfo
     
    7.打印系统分区信息
     cat /proc/partitions
     fdisk -l
    8.获取系统详细信息
     lshw

    9.列出一个小时占用CPU最多的10个进程
      SECS=3600
      UNIT_TIME=60

      STEPS=$(( $SEC / $UNIT_TIME ))

      echo Watching CPU Usaging...
      #comm表示命令名，pcpu表示cpu使用率，$$表示当前进程号
      for((i=0;i<SETPS;i++))
      do 
      	ps -eo comm,pcpu | tail -n +2 >>/tmp/cpu_usage.$$
      	sleep $UNIT_TIME
      done
      
      echo 
      echo CPU eaters:
      cat /tmp/cpu_usage.$$
      awk '{process[$1]+=$2;}END{for(i in process){printf("%-20s %s",i,process[i]);}}'| sort -nrk 2 | head
      rm /tmp/cpu_usage.$$
```
---------------------------------------------------------------------
**hostname ：操作主机名**
```bash
实例脚本：
   ：查看主机名
   hostname newname:修改主机名
```

### 权限
**基本简介**
```bash
    ls -l 
		rwxrwxrwx:
			左三位：定义user(owner)的权限
			中三位：定义group的权限；
			右三位：定义other的权限

	进程安全上下文：
		进程对文件的访问权限应用模型
			进程的属主与文件的属主是否相同；如果相同，则应用属主权
			否则，则检查进程的属主是否属于文件的属组；如果是，则应用属组权限
			否则，就只能应用other的权限

	权限：
		r：readable, 读
		w：writable, 写
		x：excutable，执行

		文件：
			r：可获取文件的数据
			w: 可修改文件的数据
			x：可将此文件运行为进程

		目录：
			r：可使用ls命令获取其下的所有文件列表
			w: 可修改此目录下的文件列表；即创建或删除文件
			x: 可cd至此目录中，且可使用ls -l来获取所有文件的详细属性信息

		mode：rwxrwxrwx
		ownership：user, group

		权限组合机制：
			--- 000 0
			--x 001 1
			-w- 010 2
			-wx 011 3
			r-- 100 4
			r-x 101 5
			rw- 110 6
			rwx 111 7
	
	特殊权限：SUID， SGID， STICKY
	    安全上下文：
	    	1、进程以某用户的身份运行； 进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作；
		    2、权限匹配模型：
		    	(1) 判断进程的属主，是否为被访问的文件属主；如果是，则应用属主的权限；否则进入第2步；
		    	(2) 判断进程的属主，是否属于被访问的文件属组；如果是，则应用属组的权限；否则进入第3步；
		    	(3) 应用other的权限；
```
---------------------------------------------------------------------
**chmod：修改文件的用户权限**
```bash
常用选项：
    -R，--reference:递归修改 
    三类用户：
		u：属主
		g：属组
		o：其它
		a: 所有
	三类操作：
		+：表示增加权限
		-：表示取消权限
		=：表示唯一设定权限
实例脚本：
    1.递归修改目录
     Eg>chmod -R /home/
    2.修改用户的属主属组其他,-a表示所有
     Eg>chmod u=rwx,g=rw,o=r filename
     Eg>chmod a+x filename
    3.数字来表示权限
     Eg>chmod 777 filename
```
---------------------------------------------------------------------
**chown：改变文件属主、属组，仅管理员可修改文件的属主和属组**
```bash
常用选项：
    chown USERNAME file....（只改变目录本身） 
        -R 递归修改（修改目录及其内部文件的属主） 
        --reference=/path/to/somefile file... 把file的属主设定为与
    somefile的属主一样（不需要指定属主） 
       chown USERNAME:GRPNAME file... 同时改变属主和属组 
       chown USERNAME,GRPNAME file... 同时改变属主和属组 
       chown :GROUPNAME file....   修改属组 
实例脚本：
    1.递归修改文件所有权
     Eg>chown -R user dir
    2.属组和属主都修改
     Eg>chown xxf.xxf filename
    3.修改文件属组
     Eg>chgry xxf filename
```
---------------------------------------------------------------------
**chgrp：修改文件属组 ，仅管理员可修改文件属组**
```bash
常用选项：
    chgrp GROUPNAME file....（只改变目录本身） 
        -R 递归修改（修改 目录及其内部文件的属组） 
         --reference=/path/to/somefile file... 把file的属主设定为与
    somefile的属组一样（不需要指定属组）   
实例脚本：
    1.修改文件属组
     Eg>chgry xxf filename
```
---------------------------------------------------------------------

**umask：文件的权限反向掩码，遮罩码**

文件：666-umask

目录：777-umask

注意：之所以文件用666去减，表示文件默认不能拥有执行权限；如果减得的结果中有执行权限，则需要将其加1
```bash
常用选项：
    :查看umask
    = value：设置umask值
```
---------------------------------------------------------------------
**SUID**
```bash
默认情况下：用户发起的进程，进程的属主是其发起者；因此，其以发起者的身份在运行； 
		
功用：用户运行某程序时，如果此程序拥有SUID权限，那么程序运行为进程时，进程的属主不是发起者，而程序文件自己的属主；
		
管理文件的SUID权限：
	chmod u+|-s FILE...
			
展示位置：属主的执行权限位
	如果属主原本有执行权限，显示为小写s; 否则，显示为大写S；
```
---------------------------------------------------------------------
**SGID**
```bash
功用：当目录属组有写权限，且有SGID权限时，那么所有属于此目录的属组，且以属组身份在此目录中新建文件或目录时，新文件的属组不是用户的基本组，而是此目录的属组；
		
管理文件的SGID权限：
	chmod g+|-s FILE...
		
展示位置：属组的执行权限位
	如果属组原本有执行权限，显示为小写s; 否则，显示为大写S；
```
---------------------------------------------------------------------
**Sticky**
```bash
功用：对于属组或全局可写的目录，组内的所有用户或系统上的所有用户对在此目录中都能创建新文件或删除所有的已有文件；如果为此类目录设置Sticky权限，则每个用户能创建新文件，且只能删除自己的文件；
		
管理文件的Sticky权限：
	chmod o+|-t FILE...
			
展示位置：其它用户的执行权限位
	如果其它用户原本有执行权限，显示为小写t; 否则，显示为大写T；

注意：系统上的/tmp和/var/tmp目录默认均有sticky权限；
		
管理特殊权限的另一方式：八进制权限
		suid sgid sticy     
		0     0    0  	0
		0     0    1  	1
		0     1    0  	2
		0     1    1  	3
		1     0    0  	4
		1     0    1  	5
		1     1    0  	6
		1     1    1  	7
				
	基于八进制方式赋权时，可于默认的三位八进制数字左侧再加一位八进制数字；
		Eg>chmod 1777 
```
---------------------------------------------------------------------
**facl：利用文件扩展保持额外的访问权限 **

文件的额外赋权机制：在原来的u,g,o之外，另一层让普通用户能控制赋权给另外的用户或组的赋权机制
```bash
    setfacl：设置某文件的控制权限 
        -m：增加facl 
           u：设定用户的时候，后面加上u:UID:perm  
             Eg>setfact -m u:UID:rw file 
           g:设置组 
        -x：取消facl 
    getfacl：查看文件的facl权限
```

### Bash
**变量**
```bash
变量赋值：name=value
	变量类型：存储格式、表示数据范围、参与的运算
		编程语言：
			强类型变量
			弱类型变量：
				bash把所有变量统统视作字符型；
				bash中的变量无需事先声明；相当于，把声明和赋值过程同时实现；
					声明：类型，变量名
	变量替换：把变量名出现的位置替换为其所指向的内存空间中数据；
	变量引用：${var_name}, $var_name
	变量名：变量名只能包含数字、字母和下划线，而且不能以数字开头；
		变量名：见名知义，命名机制遵循某种法则；不能够使用程序保留字，例如if, else, then, while等等；
				
	bash变量类型：
		本地变量：作用域仅为当前shell进程；
		环境变量：作用域为当前shell进程及其子进程；
		局部变量：作用域仅为某代码片断(函数上下文)；
		位置参数变量：当执行脚本的shell进程传递的参数；
		特殊变量：shell内置的有特殊功用的变量；
			$?：返回值
				0：成功
				1-255：失败
		本地变量：
			变量赋值：name=value
			变量引用：${name}, $name
				""：变量名会替换为其值；
				''：变量名不会替换为其值；
			查看变量：set
			撤销变量：unset name
				注意：此处非变量引用；

		环境变量：
			变量赋值：
				(1) export name=value
				(2) name=value
				    export name
				(3) declare -x name=value
				(4) name=value
					declare -x name
			变量引用：${name}, $name

			注意：bash内嵌了许多环境变量(通常为全大写字符)，用于定义bash的工作环境
				PATH, HISTFILE, HISTSIZE, HISTFILESIZE, HISTCONTROL, SHELL, HOME, UID, PWD, OLDPWD

			查看环境变量：export, declare -x, printenv, env
			撤销环境变量：unset name

		只读变量：
			(1) declare -r name
			(2) readonly name
			注意：只读变量无法重新赋值，并且不支持撤销；存活时间为当前shell进程的生命周期，随shell进程终止而终止；
```
---------------------------------------------------------------------

**引用**
```bash
    强引用：''，不可以实现命令替换
    弱引用：""，可以实现命令的替换
    命令引用：``，命令替换，同$(command)
    $(comm):把命令中的某几个子命令替换成指定命令，同反引号
      Eg>1.echo "Today is $(date +%D)"
```
---------------------------------------------------------------------
**命令行展开**
```bash
    ~：自动展开为用户的家目录，或指定的用户的家目录		
    {}：可承载一个以逗号分隔的路径列表，并能够将其展开为多个路径
     Eg>1./tmp/{a,b} 相当于 /tmp/a /tmp/b
```
---------------------------------------------------------------------
**快捷键**
```bash
    Ctrl+a：跳转至命令行行首
    Ctrl+e：跳转至命令行行尾
    Ctrl+u：删除行首至光标所在处之间的所有字符
    Ctrl+k：删除光标所在处至行尾的所有字符
    Ctrl+l：清屏，相当于clear
    tab:一次：自动补全，两次，列次所有匹配项
```
---------------------------------------------------------------------
**命令返回值，记录在$?中**
```bash
    0：成功
    1-255：错误码
     Eg>1.echo $?
```
---------------------------------------------------------------------
**文件通配符**
```bash
常用模式：
    *：匹配任意长度的任意字符
    ?：匹配任意单个字符
    []：匹配指定范围内的任意单个字符
      有几种特殊格式：
        [a-z], [A-Z], [0-9], [a-z0-9]
        [[:upper:]]：所有大写字母
        [[:lower:]]：所有小写字母
        [[:alpha:]]：所有字母
        [[:digit:]]：所有数字
        [[:alnum:]]：所有的字母和数字
        [[:space:]]：所有空白字符
        [[:punct:]]：所有标点符号
    [^]：匹配指定范围外的任意单个字符
        [^[:upper:]]
        [^0-9]
        [^[:alnum:]]
实例脚本：
    显示/var目录下所有以l开头，以一个小写字母结尾，且中间出现一位任意字符的文件或目录；
      Eg>1.ls -d /var/l?[[:lower:]]
    显示/etc目录下，以任意一位数字开头，且以非数字结尾的文件或目录；
      Eg>1.ls -d /etc/[0-9]*[^0-9]
    显示/etc目录下，以非字母开头，后面跟一个字母及其它任意长度任意字符的文件或目录；
      Eg>1.ls -d /etc/[^a-z][a-z]*
    复制/etc目录下，所有以m开头，以非数字结尾的文件或目录至/tmp/magedu.com目录；
      Eg>1.cp -r /etc/m*[^0-9] /tmp/magedu.com/
    复制/usr/share/man目录下所有以man开头，后跟一个数字结尾的文件或目录至/tmp/man/目录下；
      Eg>1.cp -r /usr/share/man/man[0-9] /tmp/man/
    复制/etc目录下，所有以.conf结尾，且以m,n,r,p开头的文件或目录至/tmp/conf.d/目录下；
      Eg>1.cp -r /etc/[mnrp]*.conf /tmp/conf.d/
```
---------------------------------------------------------------------
**I/O重定向**

0：stdin，标准输入；1，stdout，标准输出；2：stderr，标准错误
```bash
 常用种类：
    >:覆盖输出
    <:输入
    >>:追加输出
    2>:重定向错误信息输出
    2>>:重定向错误信息追加输出
    &>:重定向错误信息和标准输出至某个文件，同2>&1
     Eg>COMMAND > /path/to/somefile 2>&1
    &>>:重定向错误信息和标准输出追加至某个文件
     Eg>COMMAND >> /path/to/somefile 2>&1
    /dev/null:软件设备，数据黑洞
常用设置：
    set +C:禁止覆盖输出重定向至已存在的文件；此时可使用强制覆盖输出：>|
    set -C:关闭上述特性
```
---------------------------------------------------------------------
**tr:对输入的文本进行变化和删除**

0：stdin，标准输入；1，stdout，标准输出；2：stderr，标准错误
```bash
 常用种类：
    -d：删除指定条件数据
     Eg>1.cat file.txt | tr -d '0-9'
    -c:表示补集
     Eg>1.echo hello 1 char 2 next 4 | tr -d -c '0-9 \n'，将不再补集中的数据删除
    -s:压缩连续重复的字符至一次
     Eg>1.echo "GNU is    not   unix.Re right  ?" | tr -s ' '
实例脚本：
    1.实现计算器的功能：1+2+3...+5+，最后多了一个+，所以人为添加一个0
     Eg>cat sum.txt | echo $[ $(tr '\n' '+') 0 ]
    2.把/etc/passwd文件的前6行的信息转换为大写字符后输出
     Eg>head -n 6 /etc/passwd | tr 'a-z' 'A-Z'
    3.重定向
     Eg>tr -d SET1 < /PATH/FROM/SOMEFILE
```
---------------------------------------------------------------------
**tee:命令用于读取标准输入的数据，并将其内容输出成文件**
```bash
 常用种类：
    -a:将读取的内容追加到文件的后面，而不是覆盖（在默认的情况下是覆盖）
实例脚本：
    1.将标准输出与错误输出都重定向到同一指定文件中
     Eg>ls "*" 2>&1 | tee ls.txt
```
---------------------------------------------------------------------
**bash的配置文件**
```bash
bash的配置文件：
	
	登录类型：
		交互式登录shell进程：
			1.直接通过某终端输入账号和密码后登录打开的shell进程；
				使用su命令：su - USERNAME；
				使用 su -l USERNAME执行的登录切换；
			2.文件搜索路径：
			   /etc/profile --> /etc/profile.d/* --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc		
	非交互式登录shell进程：
			1.非交互场景
		    	-u USERNAME执行的登录切换，su -u USERNAME；；
		    	图形界面下打开的终端；
			    运行脚本
			2.配置文件搜索路径
			  ~/.bashrc --> /etc/bashrc --> /etc/profile.d/*
	两类配置文件：
		profile类：为交互式登录的shell进程提供配置
			profile类：
				全局：对所有用户都生效；
					/etc/profile 
					/etc/profile.d/*.sh
					
				用户个人：仅对当前用户有效；
					~/.bash_profile
					
				功用：
					1、用于定义环境变量；
					2、运行命令或脚本；
					
		bashrc类：为非交互式登录的shell进程提供配置			
			bashrc类：
				全局：
					/etc/bashrc 
				用户个人：
					~/.bashrc
	
				功用：
					1、定义本地变量；
					2、定义命令别名；
					
			注意：仅管理员可修改全局配置文件；
			
	
	命令行中定义的特性，例如变量和别名作用域为当前shell进程的生命周期；
	
	配置文件定义的特性，只对随后新启动的shell进程有效；
			
	让通过配置文件定义的特性立即生效：
		(1) 通过命令行重复定义一次；
		(2) 让shell进程重读配置文件；
			~]# source /PATH/FROM/CONF_FILE
			~]# .  /PATH/FROM/CONF_FILE
```
---------------------------------------------------------------------
**printf：默认没有换行符**

---------------------------------------------------------------------
**echo：文本输出命令，默认有换行符**
```bash
常用选项：
     -n：不进行换行
     -e:如果需要打印换行，则要加上-e表示启用转义符.
      Eg>1.echo -e "I love \n dinghaha"
        >2.字符串切片
         #替换部分文本
         var="This is a line of text."
          echo ${var/line/REPLACED}
         #替换字符串，从字符串的起始位置和长度来生成子串,length不给默认到结尾，start_pos为负数表示反向,此时长度不给的话表示一个字符
         #${var:start_pos:length}
         echo ${var:(-1)}
         echo ${var:(-1):2}
       >3.引号
        单引号：强引用，变量引用不执行替换
        双引号：弱引用，变量引用会被替换
```
---------------------------------------------------------------------
**set：脚本调试**
```bash
实例脚本：
    1.只会打印set之间的调试信息
     for i in {1..6}
     do
     	set -x
     	echo $i
     	set +x
     done

     echo "script executed"

     echo "user defined debug"

    2.在shell中:表示什么都不做
     function DEBUG()
     {
     	 [ "$_DEBUG" == "on" ] && $@ ||:
     }

     for i in {1..6}
     do
     	DEBUG echo $i
     done

    3.在shebang第一行后面添加一个 -xv参数
     func()
     {
     	#打印第一个参数，第二个参数
     	echo $1,$2;
     	#以列表的方式一次性打印所有参数
     	echo "$@";
     	#类似$@，但是参数被作为单个实体
     echo "$*";
     #命令的返回值
     echo "$?";
     return 0;
     }
```
---------------------------------------------------------------------
**read：交互**
```bash
常用选项：
    read：shell脚本内可以实现交互式的操作      
    read -p “提示”       
    -t：时间限制
      Eg>read -t 2 var
    -n:表示字符数
      Eg>输入中读取n(如下面的3，表示读取3个)个字符
         read -n 3 var
    -p:表示提示
    -s:表示不回显，输入密码有用
      Eg>混合使用,输入密码
         read -s -p "Enter input:" var
实例脚本：
    1.命令行输入
     Eg>read -p "Enter number:" no
     read -p "Enter name:" name
     echo You have entered $no,$
```
---------------------------------------------------------------------


### 文本三剑客
**grep：文本搜索工具,全名Global search REgular expression and Print out the line**

根据用户指定的“模式（过滤条件）”对目标文本逐行进行匹配检查；打印匹配到的行
```bash
命令格式： 
    grep  [OPTIONS]  PATTERN  [FILE...]
	grep  [OPTIONS]  [-e PATTERN | -f FILE]  [FILE...]
    模式：由正则表达式的元字符及文本字符所编写出的过滤条件
常用选项：
    --color=auto：对匹配到的文本着色后高亮显示
    -i：ignorecase，忽略字符的大小写
    -o：仅显示匹配到的字符串本身
    -v, --invert-match：显示不能被模式匹配到的行
    -E：支持使用扩展的正则表达式元字符
    -q, --quiet, --silent：静默模式，即不输出任何信息
    -A #：after, 后#行
    -B #：before，前#行
    -C #：context，前后各#行
    -R:递归搜索
    -n：打印匹配到的行号
    -l：搜索多个文件，并找出匹配的在哪个文件
      Eg>grep -l "wewe" file1 file2
    -c:统计文件匹配到的行数，注意是行数不是字数
      Eg>grep -c "a" filename
      如要想统计匹配到的个数
      Eg>grep -o "a" filename | wc -l
    -e：指定多个配置样式
      Eg>grep -e "aa" -e "bbb" filename 
    -f：从配置文件中读取过滤条件
      Eg>grep -f conf_file source_file
    --include：只在目录中搜索指定文件(c和cpp文件)
      Eg>grep "main()" . -r --include *.{c,cpp}

    --exclude：在目录中排除文件（readme）
      Eg>grep "main()" . -r --exclude "README"

    --exclude-dir：排除目录
      Eg>grep "main()" . -r --exclude-dir

    -Z：以0作为终结符的文件名\0,注意-Z一般和-l一起使用
      Eg>grep "test" file* -lZ | xargs 0 rm

    -q：启用静默模式
      Eg>grep -q "test" file
    -Ff：比较两个文件的相同的
      Eg>grep -Ff file1.txt file2.txt

    -vFf：比较两个文件不相同
      Eg>grep -vFf file1.txt file2.txt
   
基本正则表达式元字符：
    字符匹配：
		. ：匹配任意单个字符
		[]：匹配指定范围内的任意单个字符
		[^]：匹配指定范围外的任意单个字符
		[:digit:]、[:lower:]、[:upper:]、[:alpha:]、[:alnum:]、[:punct:]、[:space:]：常见单个字符
						
	匹配次数：用在要指定其出现的次数的字符的后面，用于限制其前面字符出现的次数；默认工作于贪婪模式
		*：匹配其前面的字符任意次；0,1,多次
	    .*：匹配任意长度的任意字符
		\?：匹配其前面的字符0次或1次；即其前面的字符是可有可无的
		\+：匹配其前面的字符1次或多次；即其面的字符要出现至少1次
		\{m\}：匹配其前面的字符m次；
		\{m,n\}：匹配其前面的字符至少m次，至多n次
		\{0,n\}：至多n次
		\{m,\}：至少m次
					
	位置锚定：
		^：行首锚定；用于模式的最左侧
		$：行尾锚定；用于模式的最右侧
		^PATTERN$：用于PATTERN来匹配整行
		^$：空白行
		^[[:space:]]*$：空行或包含空白字符的行
		单词：非特殊字符组成的连续字符（字符串）都称为单词
		\< 或 \b：词首锚定，用于单词模式的左侧
		\> 或 \b：词尾锚定，用于单词模式的右侧
		\<PATTERN\>：匹配完整单词
		
	分组及引用:
	    \(\)：将一个或多个字符捆绑在一起，当作一个整体进行处理；
			注意：分组括号中的模式匹配到的内容会被正则表达式引擎自动记录于内部的变量中，这些变量为：
				\1：模式从左侧起，第一个左括号以及与之匹配的右括号之间的模式所匹配到的字符；
				\2：模式从左侧起，第二个左括号以及与之匹配的右括号之间的模式所匹配到的字符；
				\3：...
				  Eg> grep  "\(l..e\).*\1"  xxf.txt
							
		后向引用：引用前面的分组括号中的模式所匹配到的字符
		
实例脚本： 
    1、显示/etc/passwd文件中不以/bin/bash结尾的行；
		Eg>grep -v "/bin/bash$" /etc/passwd
						
	2、找出/etc/passwd文件中的两位数或三位数；
		Eg>grep  "\<[0-9]\{2,3\}\>"  /etc/passwd
						
	3、找出/etc/rc.d/rc.sysinit或/etc/grub2.cfg文件中，以至少一个空白字符开头，且后面非空白字符的行；
		Eg>grep  "^[[:space:]]\+[^[:space:]]"  /etc/grub2.cfg
						
	4、找出"netstat -tan"命令的结果中以'LISTEN'后跟0、1或多个空白字符结尾的行；
		Eg>netstat -tan | grep  "LISTEN[[:space:]]*$"
```
---------------------------------------------------------------------
**egrep：支持扩展的正则表达式实现类似于grep文本过滤功能,等价于grep -E**

```bash
命令格式： 
    egrep [OPTIONS] PATTERN [FILE...]
    模式：由正则表达式的元字符及文本字符所编写出的过滤条件
常用选项：
    --color=auto：对匹配到的文本着色后高亮显示
    -i：ignorecase，忽略字符的大小写
    -o：仅显示匹配到的字符串本身
    -v, --invert-match：显示不能被模式匹配到的行
    -G：支持基本正则表达式
    -q, --quiet, --silent：静默模式，即不输出任何信息
    -A #：after, 后#行
    -B #：before，前#行
    -C #：context，前后各#行
   
扩展正则表达式的元字符：
	字符匹配：
		.：任意单个字符
		[]：指定范围内的任意单个字符
		[^]：指定范围外的任意单个字符
						
	次数匹配：
		*：任意次，0,1或多次；
		?：0次或1次，其前的字符是可有可无的；
		+：其前字符至少1次；
		{m}：其前的字符m次；
		{m,n}：至少m次，至多n次; 
		    {0,n}
		    {m,}
	位置锚定
		^：行首锚定；
		$：行尾锚定；
		\<, \b：词首锚定；
		\>, \b：词尾锚定；
	分组及引用：
		()：分组；括号内的模式匹配到的字符会被记录于正则表达式引擎的内部变量中；
		后向引用：\1, \2, ...
		或：
		    a|b：a或者b；
            C|cat：C或cat
            (c|C)at：cat或Cat
		
实例脚本： 
    1、找出/proc/meminfo文件中，所有以大写或小写S开头的行；至少有三种实现方式
		Eg>grep -i "^s" /proc/meminfo
		Eg>grep "^[sS]" /proc/meminfo
		Eg>grep -E "^(s|S)" /proc/meminfo
					
    2、显示肖前系统上root、centos或user1用户的相关信息
		Eg>grep -E "^(root|centos|user1)\>" /etc/passwd
					
    3、找出/etc/rc.d/init.d/functions文件中某单词后面跟一个小括号的行
		Eg>grep  -E  -o  "[_[:alnum:]]+\(\)" /etc/rc.d/init.d/functions
					
    4、使用echo命令输出一绝对路径，使用egrep取出基名
		Eg>echo /etc/sysconfig/ | grep  -E  -o  "[^/]+/?$"
					
    5、找出ifconfig命令结果中的1-255之间的数值
		Eg>ifconfig | grep  -E  -o  "\<([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\>"
					
    6、添加用户bash, testbash,basher以及nologin(其shell为/sbin/nologin)；而后找出/etc/passwd文件中用户名同shell名的行
		Eg>grep  -E  "^([^:]+\>).*\1$"  /etc/passwd
```
---------------------------------------------------------------------
**sed: 流编辑器,全名stream editor**

把文本中的某一行读取到内存中进行处理，此内存空间称为模式空间。默认不编辑原文件，只对模式空间内的数据进行处理,处理结束后，将没模式空间打印至屏幕

```bash
    -n ：静默模式，不在显示模式空间中的内容 
    -i ：直接修改原文件 
    -e :（-e SCRIPT -e SCRIPT） 可以同时执行多个脚本 
    -f /PATH/TO/SED_SCRIPT:执行脚本文件 
       Eg>sed -f /path/to/sed_script file
    -r :使用扩展的正则表达式 
    模式中选项：
        d：删除符合条件的行 
          Eg>/etc/inittab    删除1-2行 
             sed '/root/d' /etc/fastab 删除包含root的行 
        p:显示符合条件的行。 
          Eg>sed '/^\//d' /etc/fastb 删除以/开头的行 
            sed '/^\//p' /etc/fastb 显示以/开通的行 
        a \string:在指定的行后追加新的行，内容为string 
        i \string:在指定的行前面添加新行，内容为string 
        r FILE :将指定的文件的内容添加至符合条件的行处 
        w FILE :将地址指定范围内的内容另存至指定的文件中 
        s/pattern/string/：查找并替换(默认只替换每行中第一次被pattern匹配到的字符串)  把pattern匹配的字符换为string 
        g 全局替换   
          Eg>s/pattern/string/g 
        i 忽略字符大小写 
          Eg>s/pattern/string/i 
        s///=s###=s@@@ 在找/时就不用转意了。 
        &:后向引用,引用模式匹配的整个串
        
实例脚本：
    1.-s替换选定文本中的字符串,g表示全局替换,-i表示将结果应用于源文件
      Eg>sed -i 's/pattern/replace_str/g' file.txt

    2.Ng表示从第N处进行替换
      Eg>sed -i 's/pattern/replace_str/3g' file.txt

    3./表示定界符，我们可以使用任意的定界符
      Eg>sed -i 's:pattern:replace_str:g' file.txt

    4.\表示转义
      Eg>sed -i 's/patt\/ern/replace_str/g' file.txt

    5.d,删除空白行
      Eg>sed '/^$/d' file.txt

    6.\w\+表示匹配每个单词，&表示已匹配字符串
      Eg>sed 's/\w\+/[&]/g' file.txt

    7.\1,\2...表示匹配到的分组中的第几个,又被称作逆序引用
      Eg>sed 's/digit \([0-9]\)/\1/' file.txt

    8.组合多个表达式，利用管道
      Eg>sed "expre1" | sed "expre2"
        #等价于
        sed "expr1;expr2"

    9.sed表达式通常用单引号来引用，不过也可以使用双引号，双引号会通过表达式求值来对其进行扩展。
      Eg>text=hello
         sed "s/$text/HELLO" file.txt

    10.删除注释,其中：表示分隔符
      Eg>sed 's:/\*.*\*/::g' file.txt

    11.删除{、}、（、）、；、：之前所有的空格
      Eg>sed 's/ \?\([{ }();,:]\) \?/\1/g'

    12.p打印匹配的内容
      Eg>sed '/\(.\)\1/p' file.txt
```
---------------------------------------------------------------------
**awk: awk被设计用于数据流，可以对列和行进行操作**

一个awk脚本通常由3部分组成，BEGIN、END和能够使用模式匹配的通用语句块，次3部分是可选的，任何一部分都可以不出现在脚本中。

```bash
基本语法：
    awk [option]... 'script' FILE...
	awk [option]... '/PATTERN/{action}' FILE...
      如awk "BEGIN{statements}{statement}END{statement}"
    
执行流程：
    1.执行BEGIN，在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，注入变量初始化，打印输出表格的表头等语句通常都可以写入BEGIN语句块中
    2.从文件或stdin中读取一行，然后执行{statements}语句块，重复该过程
    3.当读至输入流结尾时，执行END{commands}语句块。END语句块和BEGIN语句块类似，在读取完所有的行之后即被执行，像打印所有行的分析结果这些汇总信息，都是在END语句信息中实现

特殊变量：
    NR:表示记录数量，在执行过程中对应于当前行号
    NF:表示字段数量，在执行过程中对应于当前行的字段数
    0：表示这个变量包含执行过程中当前行的文本内容
    1：这个变量包含第一个字段的文本内容
    2：这个变量包含第二个字段的文本内容
    $(NF-1)表示打印倒数第二个字段
      Eg>echo -e "line1 f2 f3\nline2 f4 f5\nline5 f6 f7" | awk '{print "Line no:"NR",no of fields:"NF,"$0="$0,"$1="$1,"$2="$2,"$3="$3}'

动作：
    (1)表达式：
	(2)控制语句
		if,while等
		控制语句
			if(cond){...}
			if(cond){...}else{...}
			do{..}while(0)
			for(;;){}
			break;
			continue;
			delete array[index];//表示从数组删除指定数组
			delete array;//删除整个数组
			exit{...};/退出
		if语句	
		    1.用户id大于1000的
		      Eg>awk -F: '{if($3>1000) print $1,$3}' /etc/passwd
		         awk -F: '{if($3>1000) {printf "common user %s",$1} else {printf "system user =%s",$1}}' /etc/passwd
    		2.某一行的字段数大于5，则显示
		      Eg>awk '{if(NF>5)print $0}'  /etc/fstab
		
		while语句
		  使用场景：
			1.统计每行字符个数，可以使用内建函数length
		      Eg>awk '/^[[:space:]]*linux16/{i=1;while(i<=NF){print $i,length($i)};i++}' /etc/grub.conf
		
		for语句：
		    for(var  in array){for-body}
			 
		next:提前结束本轮循环
		  Eg>awk -F:‘{if($3%2!=0) next;print $1,$3}’ /etc/passwd
		
		array:关联数组 array[index-expression]
		    1.若要判断数组中是否存在某元素，要使用index in array格式进行。不能直接饮用，否则会自动创建，默认值为空，对应整型为0.和map有点像
		      Eg>awk  'BEGIN{weekday["mon"]="Mon";weekday["tue"]="TUE";print weekday["mon"]}'---》Mon
			2.要遍历数组中的每个元素，可以使用for。
		      Eg>awk 'BEGIN{weekday["mon"]="Mon";weekday["tue"]="TUE";for(i in weekday)print weekday[i]}'
		 	3.统计一个文件中单词个数：
		      Eg>awk '{for(i=1;i<NR;i++){count[$i]++}}END{for(i in count){print i,count[i]}}' /etc/fstab   
			
	(3)组合语句
    (4)输入与输出语句
		print "string"
		print $#
		print $1,$2,...
		
内置函数：
    1.sub(1,2,$i):意思是将1替换成2，然后约定在%i这个字段，当然%i可以为空.注意这个只是替换第一次
    2.gsub注意这个是全部替换
    3.length([s]):返回指定字符串的长度
    4.split(s,a[,r]):以r为分隔符切割分隔符s，并将分割后的元素保存在数组a中
	  Eg>netstat -tan | awk '/^tcp\>/{split($5,ip,":");print ip[1]}'
		
	  Eg>netstat -tan | awk '/^tcp\>/{split($5,ip,":");count[ip[1]]++}END{for(i in count){print i,count[i]}}'
		

实例脚本：
    1.print：需要记住两件事：当print的参数是以逗号进行分隔时，参数打印则以空格作为定界符；在awk的print语句中，双引号是被当做拼接操作符使用的
      Eg>echo -e "line1\nline2" | awk 'BEGIN{print "Start"} {print}END{print "End"}'

    2.NR<5行号小于5的行
      Eg>awk 'NR<5' file.txt

    3.行号在1到5之间的
      Eg>awk 'NR==1,NR==4'

    4.打印处于start_pat和end_pat之间的文本
      Eg>awk '/start_pat/,/end_pat/' file.txt

    5.包含linux的行（正则）
      Eg>awk '/linux/'

    6.不包含linux的行
      Eg>awk '!/linux/'

    7.-v将外部变量传给awk
      Eg>var1="VAR1";var2="VAR2"
         echo | awk '{print v1,v2}' v1=$var1 v2=$var2

    8.来自文件而非标准输入
      Eg>echo | awk '{print v1,v2}' v1=$var1 v2=$var2 file.txt

    9.getline获取输入行
      Eg>seq 5 | awk 'BEGIN{getline; print "Read ahead first line :",$0}{print $0}'

    10.-F设置定界符，默认是空格
      Eg>awk -F: '{print $NF}' /etc/passwd
        #或者
        awk 'BEGIN{FS=":"}{print $NF}' /etc/passwd

    11.-OFS设置输出字段分隔符
      Eg>awk 'BEGIN{FS=":";OFS="-"}{print $NF}' /etc/passwd

    12.统计netstat -tan模式下每种状态出现多少次：
      Eg>netstat -tan | awk '{stat[$NF]++}END{for(i in stat) print i,stat[i]}'
        结果为：
			established 1
			State 1
			ESTABLISHED 2
			LISTEN 8
	13.统计log日志中，每个ip对服务器访问的资源数
      Eg>awk '{ip[$1]++}END{for(i in ip) print i,ip[i]}'
```
---------------------------------------------------------------------
**vim: 文本编辑器，是VI的加强版**

```bash
vim模式： 
    编辑模式（命令模式）：默认 
    输入模式 
    末行模式

常用命令：
    1.模式切换(以普通模式为基准)
      1.进入插入模式(Insert mode)：
        小写i：从目前光标所在处插入
       大写I：从目前光标所在行，的第一个非空字符开始插入

       小写a：从目前光标所在处的下一个字符处开始插入
       大写A：从目前光标所在行，的行尾开始插入
  
      小写o：在目前光标所在行，的下一行处插入新的一行
       大写O：在目前光标所在行，的上一行插入新的一行！

     2.进入替换模式
       r：按下后进入替换模式，替换一次后，切换回普通模式
       R：按下后进入替换模式，可以替换多次，按esc后切换回普通模式

     3.切换回普通模式
       Esc：在任何模式中按esc，都会切换到回到一般模式中
	
     4.进入行尾命令模式
        ':'：冒号，进入行尾命令模式
	  注意：上面这些按键中，在vi画面的左下角处会出现"--INSERT--"或"--REPLACE--"的字样。由名称就知道该动作了吧！
        特别注意的是，我们上面也提过了，你想要在文件里面输入字符时，一定要在左下角处看到 INSERT 戒 REPLACE 才能输入喔！

    2.光标移动(没有注明的都是普通模式的快捷键)：
      1.简单移动
          h或向左箭头：              光标向左移动一个字符
          j或向下箭头：              光标向下移动一个字符
          k或向上箭头：              光标向上移动一个字符
          l或向右箭头：              光标向右移动一个字符
       注意：如果想要进行多次移动的话，例如向下移动 30 行，可以使用 "30j" 或 "30↓" 的组合按键，亦即加上想要进行的次数(数字)后，按下动作即可

      2.翻页
          Ctrl+f：屏幕向下移动一页，相当于Page Down按键
          Ctrl+b：屏幕向上移动一页，相当于Page Up按键
          Ctrl+d：屏幕向下移动半页
          Ctrl+u：屏幕向上移动半页
          Enter：按行向后翻

      3.光标向右移动n个字符：n<space>
          解释：
             1.这个n表示数字，例如20。<space>标识空格键
	         2.按下数字后再按空格键，光标会向右移动这一行的n个字符。
		     3.例如 20<space> 则光标会向后面移动20个字符距离。

      4.光标行首行尾移动
        1.移动到行首
          0：或功能键Home：这是数字0：跳转至这一行的行首
	      ^：或功能键Home：跳转至行首的第一个非空白字符
	    2.移动到行尾
           $：或功能键End：移动到这一行的行尾

      5.光标整个屏幕的移动
       H：光标移到这个屏幕的最上方那一行的第一个字符
       M：光标移到这个屏幕的中央那一行的第一个字符
       L：光标移到这个屏幕的最下方那一行的第一个字符

      6.光标整个文件的移动
         nG：n为数字。移动到这个文件的第n行。
	       Eg>20G则会移动到这个文件的第20行(可配合 :set nu)
	    n<Enter>：n为数字。光标向下移动n行
         G：移动到这个文件的最后一行
         gg：移动到这个文件的第一行，相当于"1G"
	
      7.光标在一行中跳转(f命令和t命令)
         fx：跳到下一个x所在之处，按;继续跳到下一个x之处，,跳到上一个x之处
         Fx：跳到上一个x所在之处，按;继续跳到上一个x之处，,跳到下一个x之处
         tx：跳到下一个x所在之处的前一个字符，按;继续跳到下一个x之处的前一个字符，,跳到上一个x之处的前一个字符
         Tx：跳到上一个x所在之处的前一个字符，按;继续跳到上一个x之处的前一个字符，,跳到下一个x之处的前一个字符
	
      8.ctrl+o：前一次光标所在的位置
        ctrl+i：后一次光标所在的位置
	
      9.ctrl+w：删除光标所在处的单词(插入模式的快捷键)
	
    3.删除、复制与粘贴：
     1.删除单个字符：x命令
	  x：在一行字当中，x为向后删除一个字符 (相当于del按键)
	  X：在一行字当中，X为向前删除一个字符(相当于backspace亦即是退格键) (常用)
	  nx：n为数字，连续向后删除n个字符。举例来说，我要连续向后删除10个字符，则输入10x。
	  nX：n为数字，连续向前删除n个字符。举例来说，我要连续向前删除10个字符，则输入10x。
	
     2.删除命令：d命令
      1.普通行删除
       dd：删除光标所在的那一整行(常用)
       ndd：n为数字。删除光标所在的向下n行
	       例如：20dd则是删除20行 (常用)
       d1G：删除光标所在行，到第一行的所有数据
       dG：删除光标所在行，到最后一行的所有数据
	   d0：n是数字的0，删除光标所在的那个字符，到该行的行首的所有数据
       d$：删除光标所在的那个字符，到该行的行尾的所有数据
	  2.删除光标所在""或{}之间的所有内容：
	   di"：删除""之间的所有内容
	   da"：删除""之间的所有内容，包括双引号
       di{：删除{}之间的所有内容
	   da{：删除{}之间的所有内容，包括大括号

      3.删除后进入插入模式，c命令:
        1.行删除
        命令格式：
	     依次按下："数字n + c + 上下左右光标"：意思是朝着上下左右光标的方向，删除n行，然后进入插入模式
	    2.删除光标所在""或{}之间的所有内容，删除后进入插入模式：
        ci"：删除""之间的所有内容
        ca"：删除""之间的所有内容，包括双引号
        ci{：删除{}之间的所有内容
        ca{：删除{}之间的所有内容，包括大括号

      4.复制
       1.普通行复制
        yy：复制光标所在的那一行(常用)
        nyy：n为数字。复制光标所在的向下n行
           例如：20yy则是复制20行(常用)
        y1G：复制光标所在行，到第一行的所有数据
        yG：复制光标所在行，到最后一行的所有数据
        y0：n是数字的0，复制光标所在的那个字符，到该行行首的所有数据
        y$：复制光标所在的那个字符，到该行行尾的所有数据
	  2.复制光标所在""或{}之间的所有内容：
	    yi"：删除""之间的所有内容
	    ya"：删除""之间的所有内容，包括双引号
        yi{：删除{}之间的所有内容
	    ya{：删除{}之间的所有内容，包括大括号

     5.粘贴
      p：将已复制的数据，粘贴在光标所在行的下一行
	  P：将已复制的数据，粘贴在光标所在行的上一行
      解释：
        1.我目前光标在第20行，且已经复制了 10 行数据。则按下p后，那10行数据会粘贴在原本的20行之后，亦即由21行开始粘贴。
        2.但如果是按下P，那么原本的第20行会被推到变成30行。
	
    4.撤销，恢复和重做
     u：撤销：复原前一个动作
     Ctrl+r：恢复，恢复之前的撤销。
     注意：这个u 与Ctrl+r是很常用的指令，一个是撤销，另一个则是恢复，利用这两个功能按键，你的编辑，嘿嘿！
  
     .：就是小数点：重做，意思是重复前一个动作的意思。
     解释：如果你想要重复删除、粘贴等等动作，按下小数点"."就好了！

    5.行尾命令模式
     1.保存
      :w：将编辑的数据写入硬盘文件中(常用)
      :w!：若文件属性为"只读"时，强制写入该文件。不过，到底能不能写入，还是跟你对该文件的文件权限有关啊！
     2.另存为
      :w [filename]：将编辑的数据储存成另一个文件。
      :n1,n2 w [filename]：将 n1 到 n2 的内容储存成"filename"这个文件
     3.退出
      :q：退出vi(如文件没有保存，则vi会报错，导致无法退出)
      :q!：不保存退出vi，若曾修改过文件，又不想储存，使用!为强制离开不储存文件。
	  :wq：保存后退出
	  :wq! 则为强制保存后退出，不过，到底能不能写入保存，还是跟你对该文件的文件权限有关啊！
      注意：1.那个惊叹号(!)在vi当中，常常具有"强制"的意思

     4.'ZZ'(快捷键)：若文件没有改动，则直接退出，若档案已经被更动过，则保存后退出。
  
     5.导入其他文件数据
      :r [filename]：在编辑的数据中，读入另一个文件的数据。亦即将"filename"这个文件内容加到光标所在行后面
  
     6.执行命令
      :! command：暂时离开vi，且切换到shell，执行command命令，并显示command命令的结果
	
    6.可视化模式：
     1.v按行可视化选择
     2.ctrl+v按块可视化选择
     3.选择后按d删除，按y复制，按I插入
    
    7.搜索：
     1.光标所在处，向下查找
      /word：向光标向下寻找一个名称为word的字符串。例如要在文件内搜寻vbird这个字符串，就输入/vbird即可！
     2.光标所在处，向上查找
      ?word：向光标向上寻找一个字符串名称为 word 的字符串。
     3.重复前一次的查找动作
      n：这个n是英文按键。代表：重复前一个搜寻的动作。
        Eg>1.如果刚刚执行"/vbird"去向下搜寻"vbird"这个字符串，则按下n后，会向下继续搜寻下一个名称为"vbird"的字符串。
             2.如果是执行"?vbird"的话，那么按下n则会向上继续搜寻名称为"vbird"的字符串
      N：这个N是英文按键。和n刚好相反，代表："反向"重复前一个搜寻动作
	   Eg>1.如果刚刚执行"/vbird"去向下搜寻"vbird"这个字符串，则按下N后，会向下继续搜寻上一个名称为"vbird"的字符串。
	     2.如果是执行"?vbird"的话，那么按下N则会向下继续搜寻名称为"vbird"的字符串
      注意：使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词

    8.替换(行尾命令模式)
      注意：搜索匹配为：基本正则表达式
      1.常规命令格式：
       :n1,n2s/word1/word2/gic：
       解释：n1和n2为数字。在第n1和n2行之间寻找"word1"这个字符串，并将该字符串取代为"word2"
        Eg>在100到200行向间搜寻"vbird"并替换为"VBIRD"，命令写成:"100,200s/vbird/VBIRD/gic"。
	
	  参数：1.g：表示每一行的所有匹配到的单词，全部都执行替换
	           如果没有这个参数，则每一行只有第一个匹配到的单词执行替换
		  2.i：匹配单词的时候，忽略大小写
		       如果没有这个参数，则严格按照大小写匹配
		  3.c：替换之前要求用户确认
		       如果没有这个参数，则无提示，直接全部替换
	
      2.特殊情况：全文搜索
       :1,$s/word1/word2/gic
       :%s/word1/word2/gic
       从第一行到最后一行寻找"word1"字符串，并将该字符串替换为"word2"
	
    9.多文件多窗口
      1.打开多文件：vim FILE1 FILE2 ... -[o|O]
       -o：水平分割窗口
       -O：垂直分割窗口
       在窗口间切换：Ctrl+w, 方向键
      2.多文件切换(行尾命令模式)：
       :next  下一个
       :prev  上一个
       :first   第一个 
       :last   最后一个 
      3.退出所有文件
       :wqall 保存所有文件并退出；
       :wall 保存所有文件
       :qall 退出所有文件
      4.单个文件窗口分割
       Ctrl+w, s：水平分割窗口
       Ctrl+w, v：垂直分割窗口
       在窗口间切换：Ctrl+w, 方向键
    10.行内搜索
       f+字符，直接跳到这个字符
       ；跳到下一个这个字符
       ，跳到上一个这个字符
       
定制vim的工作特性：
	注意：在末行模式下的设定，仅对当前vim进程有效；
		永久有效：
			全局：/etc/vimrc
			用户个人：～/.vimrc
			
	1、行号
		显示：set number, 简写为set nu
		取消显示：set nomber, set nonu
	2、括号匹配高亮
		匹配：set showmatch, set sm
		取消：set nosm
	3、自动缩进
		启用：set ai
		禁用：set noai
	4、高亮搜索
		启用：set  hlsearch
		禁用：set nohlsearch
	5、语法高亮
		启用：syntax on
		禁用：syntax off 
	6、忽略字符大小写
		启用：set ic
		禁用：set noic
		
	获取帮助：
		:help
		:help subject

```
