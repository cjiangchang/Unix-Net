### 文件
**ls:查看当前目录下所有内容,全名list**
```bash
文件属性： 
      -：普通文件 
      d：目录文件 
      b：块设备 
      c：字符设备文件 
      l：符号连接文件 
      p:命令管道 
      s：套接字文件 
     
文件权限： 
      9位数字，每3位一组 ，r（可读）、w（可写）、x（可执行）
      文件硬链接次数 
      文件所属主（owner） 
      文件的属组（group） 
      文件大小（size），单位默认是字节 
   
文件时间戳：
      access time：访问时间
      modify time：修改时间
      change time：改变的时间，如修改文件属性或文件名

ls常用选项： 
      -l：显示文件属性，ls -l=ll 
      -h：做相应的单位转换显示 
      -a：显示所有文件 
      -A：显示.和..以为的所有文件 
      -d：显示目录自身属性 
      -i：显示文件的缩影接点号码（index node ，inode） 
      -r：逆序显示文件列表 
      -R：递归显示文件
```
---------------------------------------------------------------------
**cd:切换目录,全名change directory**
```bash
常用选项：
      cd：切回家目录
      cd ~：进入用户的家目录
      cd -：在当前目录和前一次所在的目录来回切换（经常使用）
      cd ..:切换至其父目录
```
---------------------------------------------------------------------
**pwd:打印当前目录，全名print working directory**

---------------------------------------------------------------------
** basename：显示一个目录的基名**

---------------------------------------------------------------------
**mkdir:创建目录，全名make directory**
```bash
常用选项：
     -p:递归创建目录       
      Eg>1.mkdir -p /home/xxf/test 
        >2.mkdir -p /home/xxf/{x/y,a/b}     
     -v:打印细节     
     -m:创建时，设置权限。包括属主属组其他  
      Eg>mkdir -m 777 -p /home/xxf/test
```
---------------------------------------------------------------------
**rmdir:删除目录，全名remove empty directories**
```bash
常用选项：
     -p：删除某目录后，如果其父目录为空，则一并删除之         
     -v:打印细节     
```
---------------------------------------------------------------------
**tree:查看目录树**
```bash
常用选项：
     -a:显示所有文件和目录
     -A:使用ASNI绘图字符显示树状图而非以ASCII字符组合
     -C:在文件和目录清单加上色彩，便于区分各种类型
     -d:显示目录名称而非内容
     -D:列出文件或目录的更改时间
     -f:在每个文件或目录之前，显示完整的相对路径名称
     -F:在执行文件，目录，Socket，符号连接，管道名称名称，各自加上"*","/","=","@","|"号
     -g:列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码
     -i:不以阶梯状列出文件或目录名称
     -I:<范本样式> 不显示符合范本样式的文件或目录名称
     -l:如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录
     -n:不在文件和目录清单加上色彩
     -N:直接列出文件和目录名称，包括控制字符
     -p:列出权限标示
     -h:同时打印文件和目录大小
      Eg>1.tree -h dir
     -P:<范本样式> 只显示符合范本样式的文件或目录名称
      Eg>1.tree dir -P "*.sh"
     -H和-o：将内容保存至指定路径下的指定格式
      Eg>1.tree dir -H http://localhost -o out.html
     -q:用"?"号取代控制字符，列出文件和目录名称
     -s:列出文件或目录大小
     -t:用文件和目录的更改时间排序
     -u:列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码
     -x:将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外
```
---------------------------------------------------------------------
**install：复制文件及设置属性​**
```bash
复制模式：
    单源复制：
       install [OPTION]... [-T] SOURCE DEST
    多源复制：
       install [OPTION]... SOURCE... DIRECTORY
       install [OPTION]... -t DIRECTORY SOURCE...
常用选项：
    -d:表示创建目录
      Eg>1.install -d dir1 dir2 ...
    -m, --mode=MODE：设定目标文件权限，默认为755
    -o, --owner=OWNER：设定目标文件属主
    -g, --group=GROUP：设定目标文件属组
```
---------------------------------------------------------------------
**mktemp：创建临时文件或目录**

mktemp会将创建的临时文件名直接返回，因此，可直接通过命令引用保存起来
```bash
常用选项：
    -d：创建临时目录
```
---------------------------------------------------------------------
**ln：创建链接**

硬件连接： 

    1、只能对文件创建，不能应用于目录，文件的硬链接次数为2 
    
    2、不能夸文件系统 
       
    3、创建硬链接会增加文件被连接的次数 
       
符号连接： 
       
    1、可应用于目录 
       
    2、可以跨文件系统 
       
    3、不会增加被连接文件的连接次数 
       
       4、其大小为指定的路径所包含的字符个数 
```bash
常用选项：
    ln SRC DEST：创建硬链接 
    -s：创建软连接 
    -i：显示文件的inode号 
    -v：显示执行详情
       
```
---------------------------------------------------------------------
**​cat：文件文本查看工具，全名concatenate**
```bash
常用选项：
     -s：压缩连续的空白行至一行
     -n 显示行号，类似于nl
      Eg>1.cat -s -n compare_and_test.sh
         #使用tr移除换行符，将连续多个\n压缩成单个
        >2.cat compare_and_test.sh | tr -s '\n'
     -T:#将制表符显示为^|，在py语言中尤其有用,区分table符号还是空格
       Eg>1.cat -T test.py
     -E:打印文件每行的结尾符$
```
---------------------------------------------------------------------
**fuser：验证进行正在使用的文件或套接字**
```bash
常用选项：
    -v：查看某文件上正在使用的进程 
    -k：把正在访问的进程给kill了 
    -km：把挂载点上的进程都关闭掉 
```
---------------------------------------------------------------------
**​dd：生成任意大小的文件**
```bash
常用选项：
    count：表示个数
    bs：表示大小
    if：输入类型，默认为stdin
    of：输出类型，默认为stdout
实例脚本：
    1.生成一个100k的测试文件
      #if如果不指定该参数，默认情况下dd会从stdin读取输入，同理如果不指定of，那么dd会将stdout作为默认输出
     Eg>dd if=/dev/zero bs=100k count=1 of=data.file
```
---------------------------------------------------------------------
**​tac：文件文本查看工具，反向**
```bash
常用选项：
     -b：打印不包括文件名在内的文件类型信息
      Eg>1.file -b $1
实例脚本：
     Eg>1.生成文件统计信息
     if [ $# -ne 1 ];
     then
        echo $0 basepath;
        echo
     fi
     path=$1
     Eg>2.数组操作
     declare -A statarray;
     while read line;
     do
     	ftype=`file -b $line`;
     	let statarray["$ftype"]++;
     done< <(find $path -type f -print)
     #返回数组的索引列表
     echo  "-------File type and counts--------"
     for ftype in "${!statarray[@]}"
     do 
     	echo $ftype:${statarray["$ftype"]}
     done
```
---------------------------------------------------------------------
**​file：查看文件类型**
```bash
常用选项：
     -n：显示行号，类似于nl
     -E:打印文件每行的结尾符$
```
---------------------------------------------------------------------
**wc：统计单词长度**
```bash
常用选项：
    -l：统计行数
     Eg>wc -l file.txt

    -c：统计字符数
     Eg>wc -c file.txt

    -w：统计单词数
     Eg>wc -w file.txt

    -L:打印最长的行
     Eg>wc -L file.txt
```
---------------------------------------------------------------------
**cut:分割文件**
```bash
常用选项：
    -d CHAR：以指定的字符为分隔符
	-f FIELDS：挑选出的字段
	    #：指定的单个字段
	     Eg>cut -f1 -d"\t" data.txt,表示表示显示第1个字段 
		#-#：连续的多个字段
		 Eg>cut -f1-3 -d"\t" data.txt,表示表示显示第1个到第3个字段 
		#,#：离散的多个字段
		 Eg>cut -f1,3 -d"\t" data.txt,表示表示显示第1个和第3个字段 
	--complement：类似反选，打印除第几行外其他的行
	  Eg>cut -f3 --complement file.txt,表示打印除第3行以外的
	--output-delimter：输出分隔符
	  Eg>cut file.txt -c/-b-3 --output-delimter "," 
```
---------------------------------------------------------------------
**sort：文本排序，仅仅是对显示文件的排序，而不影响源文件的顺序，是根据ASSII码的字符升序来排列**
```bash
常用选项：
    -n：基于数值大小而非字符进行排序
	-t CHAR：指定分隔符
	-k #：指定排序的列
	-C：判断一个文件是否排过序
	-r：逆序排序
	-o：输出文件
	  Eg>sort a.txt -o a.txt
	-f：忽略字符大小写
	-u：重复行只保留一份，这里的复复行：连续且相同
    -M：按照月份来进行排序
    -b：用于忽略文件中的前导空白字符
    -d：以字典方式进行排序
    -m：将排过序的文件合并
    -z：去除结尾符
    
实例脚本：
    1.判断是否排过序
      sort -C file.txt;
      if [ $? -eq 0 ];
     then
     	echo Sorted
     else
    	echo Unsorted
     fi
    2.排序过的文件进行排序，而且合并后不需要在进行排序
      sort -m st1 st2

    3.按第一列反序排序
     #-k,指定排序的列,可结合-nr
     #-n表示按照数字，-r表示反序，1表示列的索引
      sort -nrk 1 data.txt

    4.支持只选用键的某个范围的字符来排序
      sort -nk 2,3 data.txt

    5.使得sort的输出与以\0作为参数终止符的xargs命令相兼容
      sort -z data.txt | xargs -0

    6.忽略不必要的字符
      sort -bd unsort.txt

    7.-u重复行只打印一次
     sort  data.txt | uniq
     等价于：sort -u data.txt
```
---------------------------------------------------------------------
**uniq：报告或移除重复的行**
```bash
常用选项：
    -u:只显示唯一行
      Eg>uniq -u unsorted.txt

    -c:统计各行在文件出现的次数
      Eg>sort data.txt | uniq -c

    -d:找出重复的行
      Eg>sort unsorted | uniq -d

    -z:使用\0作为字节终止符,结合xargs使用
      Eg>uniq -z file.txt
        >uniq -z file.txt | xargs -0 rm

实例脚本：
    1.统计每个字符出现的次数
     input="ahebhaaaa"
     #第一个sed：表示在每个字符后面追加一个换行符，使得每行只出现一个字符，确保我们能够进行sort排序
     #第二个sed：最后一个空行会被替换成字符+\n，因为会多出一个换行符在最后形成一个空行，使用这个命令对其进行删除
     OUPUT=`echo %input | sed 's/[^.]/&\n/g' | sed '/^$/d' | sort | uniq -c | tr -d ' \n'`
     echo $OUTPUT
```    

---------------------------------------------------------------------
**diff:查找文件差异并进行修补**
```bash
常用选项：
    -u：使用unfied机制，即显示要修改的行的上下文，默认为3行
      Eg>diff -u a.txt b.txt
    -R：表示在撤销修改时，不会提示用户选择y/n
    -N：将所有缺失的文件视为空文件
    -a：将所有文件视为文本文件
    -u：一体化输出
    -r：递归目录下所有文件
实例脚本：
    1.生成差异文件
     Eg>diff a.txt b.txt

```    
---------------------------------------------------------------------
**patch：向文件打补丁**
```bash
实例脚本：
    1.patch将变动应用于任一一个文件
     Eg>diff -u a.txt b.txt > diff.patch
        patch -p1 a.txt < diff.patch


```    
---------------------------------------------------------------------
**paste:合并文件**
```bash
常用选项：
    -d：设置新的定界符
实例脚本：
    1.按列进行合并，默认定界符为制表符，也可以使用-d明确指定
     Eg>paste a.txt b.txt
      Eg>paste a.txt b.txt -d ","

```    
---------------------------------------------------------------------
**comm：逐行比较两个排序过的文件**
```bash
实例脚本：
    1.求两个文件的相同和不同
     Eg>sort a.txt -o a.txt;
     sort b.txt -o b.txt;
     comm a.txt b.txt 
    #输出结果中，第一列为a.txt特有的，第二列为b.txt特有的，第三列为共有的，可以使用-1，-2，-3对相应列进行过滤
    2.只显示相同的列
     Eg>comm a.txt b.txt -1 -2
    3.打印不同的列-3
     Eg>comm a.txt b.txt -3
    4.去除格式化，合并两列不同的值
     Eg>comm a.txt b.txt -3 | sed 's/^\t//'
```    
---------------------------------------------------------------------
**split：分割文件**
```bash
常用选项：
    -b：指定每个数据的大小，单位可以为k/M/G/c/w
     Eg>split -b 10k data.file

    -d:表示分割的文件数字结尾,默认是字母
    -a:表示长度
     Eg>split -b 10k data.file -d -a 4
     为分割后的文件指定前缀
     Eg>split -b 10k data.file -d -a 4 prefix

    -l:不按照数据块大小来分，按照行数来进行分割
     Eg>split -l 10 data.file
```    
---------------------------------------------------------------------
**csplit:依据指定的条件和字符串匹配选项对文件进行分割**
```bash
常用选项：
    -s:表示静默
    -n:表示分割后文件名字后缀的数字个数
    -f:表示分割后的文件前缀
    -b:指定文件格式=前缀+后缀，server+%02d.log
     Eg>csplit server.log /SERVER/ -n 2 -s {*} -f server -b "%02d.log" ; rm server00.log
     
        
```    
---------------------------------------------------------------------
**根据扩展名切分文件**
```bash
实例脚本：
    1.根据扩展名进行切分文件名
     #${VAR%.*},#从左向右执行，表示删除#左边的通配符，非贪婪；##表示执行贪婪模式
    2.提取文件名扩展名
     file_jpg="sample.jpg"
     name=${file_jpg#.*}

    3.%提取文件名，%从右向左执行，删除%右侧的通配符，属于非贪婪操作,%%表示执行贪婪操作
     file_jpg="sample.jpg"
     name=${file_jpg%.*}
        
```    
---------------------------------------------------------------------
**test：测试文件**

需要注意：[]等价于test
```bash
常用选项：
    1.文件测试
        -f:如果给定的变量包含正常的文件路径或者文件名，则返回真
         Eg>[ -f $file_var ]
        -x:如果给定的变量包含的文件可执行，则返回为真
         Eg>[ -x $var ]
        -d:如果给定的变量包含的是目录。则返回为真
         Eg>[ -d $var ]
        -e:如果给定的变量包含的是文件，则返回为真
         Eg>[ -e $var ]
        -c:如果给定的变量包含的是一个字符设备文件的路径，则返回为真
         Eg>[ -c $var ]
        -b:如果给定的变量包含一个块设备文件的路径，则返回为真
         Eg>[ -b $var ]
        -w:如果给定的变量包含的文件可写，则返回为真
         Eg>[ -w $var ]
        -r:如果包含的文件可读，则返回为真
         Eg>[ -r $var ]
        -L:如果包含的文件是一个软连接，则返回为真
         Eg>[ -L $var ]
    2.字符串测试
        =:中间的=两边的空格不能去掉，否则就变成了赋值操作
         Eg>[[ $str1 = $str2 ]][[ $str1 == $str2 ]]
         Eg>[[ $str1 != $str2 ]][[ $str1 > $str2 ]]
         Eg>[[ $str1 < $str2 ]]
        -z:如果str1包含的是空字符串，则返回为真
         Eg>[[ -z $str1 ]]
        -n:如果str1包含的是非空字符串，则返回为真
         Eg>[[ -n $str1 ]]
    3.数值测试
        -eq:等于则为真
        -ne:不等于则为真
        -gt:大于则为真
        -ge:大于等于则为真
        -lt:小于则为真
        -le:小于等于则为真
实例脚本：
    1.测试字符串是否相等
     num1="xxf"
     num2="xxf"
     if test $num1 = $num2
     then
         echo '两个字符串相等!'
     else
         echo '两个字符串不相等!'
     fi
```    
---------------------------------------------------------------------
**​stat：查看文件状态**

---------------------------------------------------------------------
**​touch：修改文件**
```bash
常用选项：
     -c: 指定的文件路径不存在时不予创建；
     -a: 仅修改access time；
     -m：仅修改modify time；
      Eg>1.touch -a/-m filename
     -t+STAMP：加时间戳
     	[[CC]YY]MMDDhhmm[.ss]
     -d:指定日期
      Eg>1.touch -a/-m filename
实例脚本：
     1.批量生成空白文件
      for name in {0..100}.txt
      do 
      	touch $name
      done
     #上述{0..100}.txt其他写法
     test{0..100}.txt
```
---------------------------------------------------------------------
**cp：拷贝文件**
cp：文件复制，规则：只有最后一个为目标。复制一个文件到一个文件  或者 多个文件
    到一个目录！ 
      cp /etc/passwd /tmp/   复制到目录下并保存原文件名 
      cp /etc/passwd /tmp/test 看test是文件还是目录，目录：负责到目录内，文件则替换！
```bash
常用选项： 
      -r：递归复制目录 
      -i：交互式显示复制 
      -f：强制复制，覆盖 
      -p：保留源文件的属性，时间戳 
      -a：保留源文件的所有属性 
      -P：复制链接文件时保存为链接（默认是复制链接所指向的文件） 
      -d：复制时保持链接 
      -a：归档复制，常用与备份
```
---------------------------------------------------------------------
**scp：Linux之间复制文件和目录，文件是通过ssh加密通道进行传输的**
```bash
常用选项： 
      -r:递归复制
       Eg>1.scp -r /home user@remotehost:/path
      -p:在复制时保留文件的权限和模式
       Eg>1.scp -r -p /home user@remotehost:/path
```
---------------------------------------------------------------------
**rm：删除文件或目录**
```bash
常用选项： 
      -i：询问是否确定删除
      -f：强制删除
      -r: 递归删除，如删除目录时
```
---------------------------------------------------------------------
**mv：移动或重命名文件 **
```bash
常用形式： 
     mv SRC DEST：当SRC和DEST同目录时，表示重命名
实例脚本：
    1.批量重命名
     Eg>count=1;
        for img in *.jpg *.png
        do
        	new=img-%count.${img##*.}
        	mv "$img" "$new" 2> /dev/null

        	if [ $? -eq 0 ];then
        		echo "rename success"
        		let count++
        	fi
        done
```

---------------------------------------------------------------------
**rename：用字符串替换的方式批量改变文件名 **
```bash
实例脚本： 
    1.支持正则
     Eg>rename 's/ /_/g'
        rename *.jpg *.jpeg
        rename 'y/A-Z/a-z/' *
    2.结合find一起使用，将所有的mp3文件移动至tmp文件夹下
      Eg>find / -type f -name "*.mp3" -exec mv {} /tmp \;
    3.将文件名中所有的空格替换成_
      Eg>find / -type f -name "*.mp3" -exec rename 's/ /_/g' {}\;
```
---------------------------------------------------------------------
**​find：实时查找工具，通过遍历指定起始路径下文件系统层级结构完成文件查找**
```bash
常用选项：
    -regex:表示正则表达式
      Eg>find / -iregex "\(\.py|\.sh\)$"
    -path:使用通配符来匹配文件路径或者文件
    -name:使用给定的文件名来进行匹配
    -i：表示忽略大小写
    -o：表示或者，多条规律条件
      Eg>find / -iname "*.sh" -o -name "*.txt"
    !:表示取反
      Eg>find / ! -name "*.txt" 

    -maxdepth/-mindepth:递归多级查找
      Eg>递归打印当前以及下一级的目录中文件
         find / -maxdepth 2 -type f 
    -type:根据文件类型来进行查找.常见的如下：
       f:文件，d：目录，l：链接，c字符设备，b表示块设备，s表示套接字，p表示管道
      Eg>find / -type f/d/l/c/b/s/p
    
    根据文件时间来进行查找,常见如下：
        按天：
            atime:表示访问时间
            mtime表示最后一次修改的时间
            ctime表示文件元数据最后一次被修改的时间，默认单位为天
        按分钟
            amin:表示访问时间
            mmin:表示最后一次修改的时间
            cmin:表示文件元数据最后一次被修改的时间，默认单位为分钟
    +:表示大于
    -:表示小于
    啥都没有表示等于
     Eg>find / -atime/-mtime/-ctime +/-/7 
    -newer：表示用于比较时间戳的参考文件，比file.txt更新的文件
      Eg>find / -type f -newer file.txt 
    -size:文件大小进行搜索,k/M/G，w子（2个字节），b表示块，c表示字节
     Eg>find / -size +/-/10k
    -delete:删除匹配的行
      Eg>find / -type -f -name "*.txt" -delete
    -perm:根据权限来进行查找
      Eg>find / -type f -perm 644

    -user:根据用户来进行查找
      Eg>find / -type f -user xiaxuefei 
    
    -exec：实现更复杂的功能
    
    -print：输出至标准输出；默认的动作
    
	-ls：类似于对查找到的文件执行“ls -l”命令，输出文件的详细信息
	-fls /PATH/TO/SOMEFILE：把查找到的所有文件的长格式信息保存至指定文件中；
	-ok COMMAND {} \; ：对查找到的每个文件执行由COMMAND表示的命令；每次操作都由用户进行确认
    -prune:使用过滤器
      Eg>find / -type f -name "*.sh" -prune 
实例脚本：
    1.chown修改属主数组
      对于每一个匹配的文件，{}会被替换成相应的文件名
      Eg>find / -type f -user root -exec chown xxf {}\;
    2.cat把所有*.c文件追加到一个文件中
      Eg>find / -type f -name "*.c" -exec cat {} \;>all_c_files.txt
    3.cp命令实现文件的复制
      Eg>find / -type f -mtime +10 -name "*.c" -exec cp {} OLD \;
    4.打印选中的文件
      Eg>find / -type f -name "*.txt" -exec printf "Text file:%s\n" {} \;
    5.查找/usr目录下不属于root, bin或hadoop的所有文件或目录
      Eg>find /usr -not \( -user root -o -user bin -o -user hadoop \) -ls
    
```
---------------------------------------------------------------------
**locate：依赖于事先构建好的索引库**

更新策略：

系统自动实现（周期性任务）；

手动更新数据库（updatedb）
```bash
常用选项：
    -b：只匹配路径中的基名；
	-c：统计出共有多少个符合条件的文件；
	-r：BRE

```
---------------------------------------------------------------------








### 命令帮助
**type：显示指定命令所属类型，命令分为内置和外部两种类型**
```bash
常用选项：
     type+command
```
---------------------------------------------------------------------
**whatis:输出作为参数的命令的简短描述**
```bash
常用选项：
     whatis+command
```
---------------------------------------------------------------------
**whereis:返回命令的路径，而且还会打印其对应的命令手册的位置和源代码的位置**
```bash
常用选项：
     whereis+command
     -b：仅搜索二进制程序路径
     -m：仅搜索使用手册文件路径
```
---------------------------------------------------------------------
**which:找出某个命令的位置**
```bash
常用选项：
     which+command
     --skip-alias：忽略别名
```
---------------------------------------------------------------------
**printenv：打印环境变量**

---------------------------------------------------------------------
**hash：查看最近命令命中次数,可参照history**
```bash
常用选项：
    ：列出
	-d COMMAND：删除
	-r：清空
```
---------------------------------------------------------------------
**history：查看命令历史，同Ctrl+R**
```bash
常用选项：
    -c: 清空命令历史
    -d offset：删除指定命令历史
    -r: 从文件读取命令历史至历史列表中
    -w：把历史列表中的命令追加至历史文件中
    history #：显示最近的#条命令

常用操作：
    !#：再一次执行历史列表中的第#条命令；
    !!：再一次执行上一条命令；
    !STRING：再一次执行命令历史列表中最近一个以STRING开头的命令； 
    ESC+.：上条指令，同!$
配置参数：
     HISTSIZE：shell进程可保留的命令历史的条数
     HISTFILE：持久保存命令历史的文件，见.bash_history
     HISTFILESIZE：命令历史文件的大小
     HISTCONTROL：命令输出方式
        =ignoredups：忽略重复的命令
        =ignorespace：忽略以空白字符开头的命令
        =ignoreboth：以上两者同时生效
```
---------------------------------------------------------------------
**alias：设置别名**
```bash
常用方式：
     alias NAME='COMMAND'：仅对当前shell有用
```
---------------------------------------------------------------------
**unalias：取消别名**
```bash
常用方式：
     unalias NAME
```
---------------------------------------------------------------------
**more：分屏显示，翻屏至文件尾部后自动退出**

---------------------------------------------------------------------
**less：分屏显示，显示文件信息，默认不退出显示，q即可退出**
```bash
常用选项：
     空格：向后翻一屏 
     b：向前翻一屏 
     ENTER：向后翻一行 
     k：向前翻一行 
     关键字查找 
       /KEYWORD：查找关键字
         n：下一个
         N：上一个         
```
---------------------------------------------------------------------
**head：查看前n行**
```bash
常用选项：
     -n：显示前n行，默认为10
```
---------------------------------------------------------------------
**tail：查看后n行**
```bash
常用选项：
    -n：显示后n行，默认为10
     Eg>1.tail -n x file.txt
    -x：打印前x行之外的所有行
     Eg>1.tail -n +x file.txt
    -f：动态输出,有新的内容会输出值屏幕
     Eg>1.tail -f file.txt
    --pid：监视某个进程
     Eg>1.pidnum=$(pidof xxx)
       >tail -f file.txt --pid $pidnum
```


### 文档
**info:查看命令在线文档**
```bash
常用选项：
     info+command
```
---------------------------------------------------------------------
**help:查看命令文档，指内部命令**
```bash
常用选项：
     help+command
```
---------------------------------------------------------------------
**man：查看外部命令的帮助文档，在man模式下**
```bash
常用选项：
     -M：到指定目录下查找命令手册并打开
     man+command

man命令打开手册以后的操作方法：
    翻屏：
       空格键：向文件尾翻一屏；
       b: 向文件首部翻一屏；
       Ctrl+d：向文件尾部翻半屏；
       Ctrl+u：向文件首部翻半屏；
       回车键：向文件尾部翻一行；
       k: 向文件首部翻一行；
       G：跳转至最后一行；
	    Eg>1.#G: 跳转至指定行；
	      >2.1G：跳转至文件首部；       
    文本搜索：
       /keyword：从文件首部向文件尾部依次查找；不区分字符大小写；
       ?keyword：从文件尾部向文件首部依次查找；
       注意：
           n: 与查找命令方向相同
           N: 与查找命令方向相反
    退出：
       q
```
---------------------------------------------------------------------
### 时间
在Linux中，系统启动时从硬件读取日期和时间信息；读取完成以后，就不再与硬件相关联；时间分为系统时钟和硬件时钟。
**date：系统时钟**
```bash
常用选项：
      %F、%T、%Y、%m、%d、%H、%M、%S、%s: 从1970年1月1号(unix元年)0点0分0秒到命令执行那一刻经过的秒数
       Eg>date +%Y
```
---------------------------------------------------------------------
**hwclock：修改硬件时间**
```bash
常用选项：
     -w：将系统时间修改为硬件时间，以系统时间为准
     -s：将硬件时间修改系统为时间，以硬件时间为准
     -r:显示硬件时间,同clock 
```
---------------------------------------------------------------------
**cal：日历**
```bash
常用选项：
     -m：显示月
     -y：显示年
```
---------------------------------------------------------------------

### 用户与组
**基本简介**
```bash
用户管理基础概念：
	用户类别：
		管理员（0）
		普通用户
		    系统用户组：1-499(CentOS6), 1-999(CentOS7)
			登录用户组：500-60000(CentOS6), 1000-60000(CentOS7)）
	组类别：
		组类别1：
			管理员组
			普通用户组
				系统组
				登录组

		组标识：GroupID, GID
			管理员组：0
				普通用户组：1-65635
					系统用户组：1-499(CentOS6), 1-999(CentOS7)
					登录用户组：500-60000(CentOS6), 1000-60000(CentOS7)	

		名称解析：groupname <--> gid
			解析库：/etc/group	

		组类别2：
			用户的基本组
			用户的附加组

		组类别3:
			私有组：组名同用户名，且只包含一个用户；
			公共组：组内包含了多个用户；
	认证信息：
			通过比对事先存储的，与登录时提供的信息是否一致；
			password：
				/etc/shadow
				/etc/gshadow
				
			密码的使用策略：
				1、使用随机密码；
				2、最短长度不要低于8位；
				3、应该使用大写字母、小写字母、数字和标点符号四类字符中至少三类；
				4、定期更换；

			加密算法：
				对称加密：加密和解密使用同一个密码；
				非对称加密：加密和解密使用的一对儿密钥；
					密钥对儿：
						公钥：public key
						私钥: private key
				单向加密：只能加密，不能解密；提取数据特征码；
					定长输出
					雪崩效应

				常见算法：
					md5: message digest, 128bits
					sha：secure hash algorithm, 160bits
					sha224
					sha256
					sha384
					sha512
					在计算之时加salt，添加的随机数
	数据库文件：
		/etc/passwd:用户的信息库
			格式：login:password:uid:gid:comment:home:shell
			 注释：
			   name: 用户名
			   password：可以是加密的密码，也可是占位符x；
			   UID：
			   GID：用户所属的主组的ID号；
			   GECOS：注释信息
			   directory：用户的家目录；
			   shell：用户的默认shell，登录时默认shell程序；
		/etc/shadow:用户密码
			格式：login:encrpted_password:...
			注释：
			   用户名:加密的密码:最近一次修改密码的时间:最短使用期限:最长使用期限:警告期段:过期期限:保留字段
		/etc/group:组的信息库
			格式：group:password:gid:user_list
            注释：
              user_list为该组的用户成员；以此组为附加组的用户的用户列表
		密码存储格式：单向加密，并借助于salt完成
```		


**who：查看正在运行的用户**
```bash
常用选项：
     -b:本次系统启动时间
     -r：运行级别
```
---------------------------------------------------------------------
 **w：查看登录的用户**
 
 ---------------------------------------------------------------------
 **whoami：显示当前用户**
 
---------------------------------------------------------------------
 **finger：查看当前用户信息**
 ```bash
 常用选项：
    ：表示查看当前用户
    finger +用户名：查看指定用户名信息
 ```
---------------------------------------------------------------------
**last：查看最后一次启动及其登录会话信息**
```bash
实例脚本：
    last reboot：最后重启时间
```
---------------------------------------------------------------------
**lastb：获取失败的用户登录会话信息**

---------------------------------------------------------------------
**users：查看当前登录的主机列表**

---------------------------------------------------------------------
**id：显示用户的真和有效ID**
```bash
常用选项：
    -u: 仅显示有效的UID
    -g: 仅显示用户的基本组ID;
    -G：仅显示用户所属的所有组的ID
    -n: 显示名字而非ID
```
---------------------------------------------------------------------
**su：切换用户，全名switch user**
```bash
常用选项：
    登录式切换：会通过读取目标用户的配置文件来重新初始化
	su - USERNAME
	su -l USERNAME
    非登录式切换：不会读取目标用户的配置文件进行初始化
	su USERNAME
    注意：管理员可无密码切换至其它任何用户
```
---------------------------------------------------------------------
**chage：更改用户密码过期信息**
```bash
常用选项：
     -d：最后一次修改时间 
     -E：过期时间 
     -I：非活动时间 
     -m：最短期限 
     -M：最长期限 
     -W：警告时间 
```
---------------------------------------------------------------------
**newgrp：临时切换指定的组为基本组**
```bash
常用选项：
     -: 会模拟用户重新登录以实现重新初始化其工作环境
```
---------------------------------------------------------------------
**gpasswd：修改组密码**

组密码文件：/etc/gshadow
```bash
常用选项：
     -a USERNAME：向组中添加用户
	 -d USERNAME：从组中移除用户
```
---------------------------------------------------------------------
**groupdel：删除组**

---------------------------------------------------------------------
**groupmod：修改组属性**

```bash
常用选项：
    -g GID：修改GID
	-n new_name：修改组名
```
---------------------------------------------------------------------
**groupadd：添加组**

```bash
常用选项：
    -g GID：指定GID；默认是上一个组的GID+1
	-r: 创建系统组
```
---------------------------------------------------------------------
**passwd：修改用户密码**

密码文件：/etc/shadow
```bash
常用选项：
     ：直接修改当前用户自己密码
	-l, -u：锁定和解锁用户；
	-d：清除用户密码串；
	-e DATE: 过期期限，日期；
	-i DAYS：非活动期限；
	-n DAYS：密码的最短使用期限；
	-x DAYS：密码的最长使用期限；
	-w DAYS：警告期限
	--stdin：从命令行输入新密码
	 Eg>echo "PASSWORD" | passwd --stdin USERNAME
实例脚本：
    1.从屏幕输入密码：
     echo -e "Enter password:"
     #禁止将输入输出到屏幕
     stty -echo
     read password
     #允许将输入输出至屏幕
     stty echo
     echo
     echo Password read.
```
---------------------------------------------------------------------
**userdel：删除用户**

```bash
常用选项：
     ：只删除用户，不删除家目录
	-r：删除用户时，一并删除其家目录
```
---------------------------------------------------------------------
**usermod：修改用户属性**

```bash
常用选项：
	-u, --uid UID：修改用户的ID为此处指定的新UID
	-g, --gid GROUP：修改用户所属的基本组
	-G, --groups GROUP1[,GROUP2,...[,GROUPN]]]：修改用户所属的附加组；原来的附加组会被覆盖
	-a, --append：与-G一同使用，用于为用户追加新的附加组；
	-c, --comment COMMENT：修改注释信息
	-d, --home HOME_DIR：修改用户的家目录；用户原有的文件不会被转移至新位置
	-m, --move-home：只能与-d选项一同使用，用于将原来的家目录移动为新的家目录
	-l, --login NEW_LOGIN：修改用户名
	-s, --shell SHELL：修改用户的默认shell
	-L, --lock：锁定用户密码；即在用户原来的密码字符串之前添加一个"!"
	-U, --unlock：解锁用户的密码
```
---------------------------------------------------------------------
**useradd：创建用户**

创建用户时的诸多默认设定配置文件：/etc/login.defs
```bash
常用选项：
	-u, --uid UID：指定UID
	-g, --gid GROUP：指定基本组ID，此组得事先存在
	-G, --groups GROUP1[,GROUP2,...[,GROUPN]]]：指明用户所属的附加组，多个组之间用逗号分隔
	-c, --comment COMMENT：指明注释信息
	-d, --home HOME_DIR：以指定的路径为用户的家目录；通过复制/etc/skel此目录并重命名实现；指定的家目录路径如果事先存在，则不会为用户复制环境配置文件
	-s, --shell SHELL：指定用户的默认shell，可用的所有shell列表存储在/etc/shells文件中
	-r, --system：创建系统用户
	-D：显示创建用户的默认配置，默认修改的文件位于：/etc/default/useradd
实例脚本：
    1.创建一个用户为xxf，全名为xiaxuefei，默认shell为xshell
      Eg>useradd -c “xiaxuefei” -s /bin/tcsh  xxf
```
---------------------------------------------------------------------

### 系统
**shutdown：关机或重启**
```bash
常用选项：
     -h:halt，关机，等价于poweroff、halt、systemctl poweroff
     -r：重启，等价于reboot
     -c：取消关机
      now：立即
      hh:mm：绝对时间，几点几时执行操作
       wall：提示消息
```
---------------------------------------------------------------------
**uptime：查看系统运行多久**
```bash
实例脚本：
    IP_LIST='192.168.147.1 192.168.147.2'
    USER='test'
    for ip in $IP_LIST;
    do 
    	utime=$(ssh $USER@$IP uptime | awk '{print $3}')
    	echo $IP uptime: $utime
    done
```
---------------------------------------------------------------------
**系统与CPU**
```bash
实例脚本：
    1.打印当前系统主机名
     hostname
     uname -n

    2.打印版本号、架构信息
     uname -a

    3.打印内核发型版本
     uname -r

    4.打印主机类型
     uname -m
     
    5.打印cpu相关信息
     cat /proc/cpuinfo

    6.打印内存相关信息
     cat /proc/meminfo
     
    7.打印系统分区信息
     cat /proc/partitions
     fdisk -l
    8.获取系统详细信息
     lshw

    9.列出一个小时占用CPU最多的10个进程
      SECS=3600
      UNIT_TIME=60

      STEPS=$(( $SEC / $UNIT_TIME ))

      echo Watching CPU Usaging...
      #comm表示命令名，pcpu表示cpu使用率，$$表示当前进程号
      for((i=0;i<SETPS;i++))
      do 
      	ps -eo comm,pcpu | tail -n +2 >>/tmp/cpu_usage.$$
      	sleep $UNIT_TIME
      done
      
      echo 
      echo CPU eaters:
      cat /tmp/cpu_usage.$$
      awk '{process[$1]+=$2;}END{for(i in process){printf("%-20s %s",i,process[i]);}}'| sort -nrk 2 | head
      rm /tmp/cpu_usage.$$
```
---------------------------------------------------------------------
**hostname ：操作主机名**
```bash
实例脚本：
   ：查看主机名
   hostname newname:修改主机名
```

### 权限
**基本简介**
```bash
    ls -l 
		rwxrwxrwx:
			左三位：定义user(owner)的权限
			中三位：定义group的权限；
			右三位：定义other的权限

	进程安全上下文：
		进程对文件的访问权限应用模型
			进程的属主与文件的属主是否相同；如果相同，则应用属主权
			否则，则检查进程的属主是否属于文件的属组；如果是，则应用属组权限
			否则，就只能应用other的权限

	权限：
		r：readable, 读
		w：writable, 写
		x：excutable，执行

		文件：
			r：可获取文件的数据
			w: 可修改文件的数据
			x：可将此文件运行为进程

		目录：
			r：可使用ls命令获取其下的所有文件列表
			w: 可修改此目录下的文件列表；即创建或删除文件
			x: 可cd至此目录中，且可使用ls -l来获取所有文件的详细属性信息

		mode：rwxrwxrwx
		ownership：user, group

		权限组合机制：
			--- 000 0
			--x 001 1
			-w- 010 2
			-wx 011 3
			r-- 100 4
			r-x 101 5
			rw- 110 6
			rwx 111 7
	
	特殊权限：SUID， SGID， STICKY
	    安全上下文：
	    	1、进程以某用户的身份运行； 进程是发起此进程用户的代理，因此以此用户的身份和权限完成所有操作；
		    2、权限匹配模型：
		    	(1) 判断进程的属主，是否为被访问的文件属主；如果是，则应用属主的权限；否则进入第2步；
		    	(2) 判断进程的属主，是否属于被访问的文件属组；如果是，则应用属组的权限；否则进入第3步；
		    	(3) 应用other的权限；
```
---------------------------------------------------------------------
**chmod：修改文件的用户权限**
```bash
常用选项：
    -R，--reference:递归修改 
    三类用户：
		u：属主
		g：属组
		o：其它
		a: 所有
	三类操作：
		+：表示增加权限
		-：表示取消权限
		=：表示唯一设定权限
实例脚本：
    1.递归修改目录
     Eg>chmod -R /home/
    2.修改用户的属主属组其他,-a表示所有
     Eg>chmod u=rwx,g=rw,o=r filename
     Eg>chmod a+x filename
    3.数字来表示权限
     Eg>chmod 777 filename
```
---------------------------------------------------------------------
**chown：改变文件属主、属组，仅管理员可修改文件的属主和属组**
```bash
常用选项：
    chown USERNAME file....（只改变目录本身） 
        -R 递归修改（修改目录及其内部文件的属主） 
        --reference=/path/to/somefile file... 把file的属主设定为与
    somefile的属主一样（不需要指定属主） 
       chown USERNAME:GRPNAME file... 同时改变属主和属组 
       chown USERNAME,GRPNAME file... 同时改变属主和属组 
       chown :GROUPNAME file....   修改属组 
实例脚本：
    1.递归修改文件所有权
     Eg>chown -R user dir
    2.属组和属主都修改
     Eg>chown xxf.xxf filename
    3.修改文件属组
     Eg>chgry xxf filename
```
---------------------------------------------------------------------
**chgrp：修改文件属组 ，仅管理员可修改文件属组**
```bash
常用选项：
    chgrp GROUPNAME file....（只改变目录本身） 
        -R 递归修改（修改 目录及其内部文件的属组） 
         --reference=/path/to/somefile file... 把file的属主设定为与
    somefile的属组一样（不需要指定属组）   
实例脚本：
    1.修改文件属组
     Eg>chgry xxf filename
```
---------------------------------------------------------------------

**umask：文件的权限反向掩码，遮罩码**

文件：666-umask

目录：777-umask

注意：之所以文件用666去减，表示文件默认不能拥有执行权限；如果减得的结果中有执行权限，则需要将其加1
```bash
常用选项：
    :查看umask
    = value：设置umask值
```
---------------------------------------------------------------------
**SUID**
```bash
默认情况下：用户发起的进程，进程的属主是其发起者；因此，其以发起者的身份在运行； 
		
功用：用户运行某程序时，如果此程序拥有SUID权限，那么程序运行为进程时，进程的属主不是发起者，而程序文件自己的属主；
		
管理文件的SUID权限：
	chmod u+|-s FILE...
			
展示位置：属主的执行权限位
	如果属主原本有执行权限，显示为小写s; 否则，显示为大写S；
```
---------------------------------------------------------------------
**SGID**
```bash
功用：当目录属组有写权限，且有SGID权限时，那么所有属于此目录的属组，且以属组身份在此目录中新建文件或目录时，新文件的属组不是用户的基本组，而是此目录的属组；
		
管理文件的SGID权限：
	chmod g+|-s FILE...
		
展示位置：属组的执行权限位
	如果属组原本有执行权限，显示为小写s; 否则，显示为大写S；
```
---------------------------------------------------------------------
**Sticky**
```bash
功用：对于属组或全局可写的目录，组内的所有用户或系统上的所有用户对在此目录中都能创建新文件或删除所有的已有文件；如果为此类目录设置Sticky权限，则每个用户能创建新文件，且只能删除自己的文件；
		
管理文件的Sticky权限：
	chmod o+|-t FILE...
			
展示位置：其它用户的执行权限位
	如果其它用户原本有执行权限，显示为小写t; 否则，显示为大写T；

注意：系统上的/tmp和/var/tmp目录默认均有sticky权限；
		
管理特殊权限的另一方式：八进制权限
		suid sgid sticy     
		0     0    0  	0
		0     0    1  	1
		0     1    0  	2
		0     1    1  	3
		1     0    0  	4
		1     0    1  	5
		1     1    0  	6
		1     1    1  	7
				
	基于八进制方式赋权时，可于默认的三位八进制数字左侧再加一位八进制数字；
		Eg>chmod 1777 
```
---------------------------------------------------------------------
**facl：利用文件扩展保持额外的访问权限 **

文件的额外赋权机制：在原来的u,g,o之外，另一层让普通用户能控制赋权给另外的用户或组的赋权机制
```bash
    setfacl：设置某文件的控制权限 
        -m：增加facl 
           u：设定用户的时候，后面加上u:UID:perm  
             Eg>setfact -m u:UID:rw file 
           g:设置组 
        -x：取消facl 
    getfacl：查看文件的facl权限
```

### Bash
**变量**
```bash
变量赋值：name=value
	变量类型：存储格式、表示数据范围、参与的运算
		编程语言：
			强类型变量
			弱类型变量：
				bash把所有变量统统视作字符型；
				bash中的变量无需事先声明；相当于，把声明和赋值过程同时实现；
					声明：类型，变量名
	变量替换：把变量名出现的位置替换为其所指向的内存空间中数据；
	变量引用：${var_name}, $var_name
	变量名：变量名只能包含数字、字母和下划线，而且不能以数字开头；
		变量名：见名知义，命名机制遵循某种法则；不能够使用程序保留字，例如if, else, then, while等等；
				
	bash变量类型：
		本地变量：作用域仅为当前shell进程；
		环境变量：作用域为当前shell进程及其子进程；
		局部变量：作用域仅为某代码片断(函数上下文)；
		位置参数变量：当执行脚本的shell进程传递的参数；
		特殊变量：shell内置的有特殊功用的变量；
			$?：返回值
				0：成功
				1-255：失败
		本地变量：
			变量赋值：name=value
			变量引用：${name}, $name
				""：变量名会替换为其值；
				''：变量名不会替换为其值；
			查看变量：set
			撤销变量：unset name
				注意：此处非变量引用；

		环境变量：
			变量赋值：
				(1) export name=value
				(2) name=value
				    export name
				(3) declare -x name=value
				(4) name=value
					declare -x name
			变量引用：${name}, $name

			注意：bash内嵌了许多环境变量(通常为全大写字符)，用于定义bash的工作环境
				PATH, HISTFILE, HISTSIZE, HISTFILESIZE, HISTCONTROL, SHELL, HOME, UID, PWD, OLDPWD

			查看环境变量：export, declare -x, printenv, env
			撤销环境变量：unset name

		只读变量：
			(1) declare -r name
			(2) readonly name
			注意：只读变量无法重新赋值，并且不支持撤销；存活时间为当前shell进程的生命周期，随shell进程终止而终止；
```
---------------------------------------------------------------------

**引用**
```bash
    强引用：''，不可以实现命令替换
    弱引用：""，可以实现命令的替换
    命令引用：``，命令替换，同$(command)
    $(comm):把命令中的某几个子命令替换成指定命令，同反引号
      Eg>1.echo "Today is $(date +%D)"
```
---------------------------------------------------------------------
**命令行展开**
```bash
    ~：自动展开为用户的家目录，或指定的用户的家目录		
    {}：可承载一个以逗号分隔的路径列表，并能够将其展开为多个路径
     Eg>1./tmp/{a,b} 相当于 /tmp/a /tmp/b
```
---------------------------------------------------------------------
**快捷键**
```bash
    Ctrl+a：跳转至命令行行首
    Ctrl+e：跳转至命令行行尾
    Ctrl+u：删除行首至光标所在处之间的所有字符
    Ctrl+k：删除光标所在处至行尾的所有字符
    Ctrl+l：清屏，相当于clear
    tab:一次：自动补全，两次，列次所有匹配项
```
---------------------------------------------------------------------
**命令返回值，记录在$?中**
```bash
    0：成功
    1-255：错误码
     Eg>1.echo $?
```
---------------------------------------------------------------------
**文件通配符**
```bash
常用模式：
    *：匹配任意长度的任意字符
    ?：匹配任意单个字符
    []：匹配指定范围内的任意单个字符
      有几种特殊格式：
        [a-z], [A-Z], [0-9], [a-z0-9]
        [[:upper:]]：所有大写字母
        [[:lower:]]：所有小写字母
        [[:alpha:]]：所有字母
        [[:digit:]]：所有数字
        [[:alnum:]]：所有的字母和数字
        [[:space:]]：所有空白字符
        [[:punct:]]：所有标点符号
    [^]：匹配指定范围外的任意单个字符
        [^[:upper:]]
        [^0-9]
        [^[:alnum:]]
实例脚本：
    显示/var目录下所有以l开头，以一个小写字母结尾，且中间出现一位任意字符的文件或目录；
      Eg>1.ls -d /var/l?[[:lower:]]
    显示/etc目录下，以任意一位数字开头，且以非数字结尾的文件或目录；
      Eg>1.ls -d /etc/[0-9]*[^0-9]
    显示/etc目录下，以非字母开头，后面跟一个字母及其它任意长度任意字符的文件或目录；
      Eg>1.ls -d /etc/[^a-z][a-z]*
    复制/etc目录下，所有以m开头，以非数字结尾的文件或目录至/tmp/magedu.com目录；
      Eg>1.cp -r /etc/m*[^0-9] /tmp/magedu.com/
    复制/usr/share/man目录下所有以man开头，后跟一个数字结尾的文件或目录至/tmp/man/目录下；
      Eg>1.cp -r /usr/share/man/man[0-9] /tmp/man/
    复制/etc目录下，所有以.conf结尾，且以m,n,r,p开头的文件或目录至/tmp/conf.d/目录下；
      Eg>1.cp -r /etc/[mnrp]*.conf /tmp/conf.d/
```
---------------------------------------------------------------------
**I/O重定向**

0：stdin，标准输入；1，stdout，标准输出；2：stderr，标准错误
```bash
 常用种类：
    >:覆盖输出
    <:输入
    >>:追加输出
    2>:重定向错误信息输出
    2>>:重定向错误信息追加输出
    &>:重定向错误信息和标准输出至某个文件，同2>&1
     Eg>COMMAND > /path/to/somefile 2>&1
    &>>:重定向错误信息和标准输出追加至某个文件
     Eg>COMMAND >> /path/to/somefile 2>&1
    /dev/null:软件设备，数据黑洞
常用设置：
    set +C:禁止覆盖输出重定向至已存在的文件；此时可使用强制覆盖输出：>|
    set -C:关闭上述特性
```
---------------------------------------------------------------------
**tr:对输入的文本进行变化和删除**

0：stdin，标准输入；1，stdout，标准输出；2：stderr，标准错误
```bash
 常用种类：
    -d：删除指定条件数据
     Eg>1.cat file.txt | tr -d '0-9'
    -c:表示补集
     Eg>1.echo hello 1 char 2 next 4 | tr -d -c '0-9 \n'，将不再补集中的数据删除
    -s:压缩连续重复的字符至一次
     Eg>1.echo "GNU is    not   unix.Re right  ?" | tr -s ' '
实例脚本：
    1.实现计算器的功能：1+2+3...+5+，最后多了一个+，所以人为添加一个0
     Eg>cat sum.txt | echo $[ $(tr '\n' '+') 0 ]
    2.把/etc/passwd文件的前6行的信息转换为大写字符后输出
     Eg>head -n 6 /etc/passwd | tr 'a-z' 'A-Z'
    3.重定向
     Eg>tr -d SET1 < /PATH/FROM/SOMEFILE
```
---------------------------------------------------------------------
**tee:命令用于读取标准输入的数据，并将其内容输出成文件**
```bash
 常用种类：
    -a:将读取的内容追加到文件的后面，而不是覆盖（在默认的情况下是覆盖）
实例脚本：
    1.将标准输出与错误输出都重定向到同一指定文件中
     Eg>ls "*" 2>&1 | tee ls.txt
```
---------------------------------------------------------------------
**bash的配置文件**
```bash
bash的配置文件：
	
	登录类型：
		交互式登录shell进程：
			1.直接通过某终端输入账号和密码后登录打开的shell进程；
				使用su命令：su - USERNAME；
				使用 su -l USERNAME执行的登录切换；
			2.文件搜索路径：
			   /etc/profile --> /etc/profile.d/* --> ~/.bash_profile --> ~/.bashrc --> /etc/bashrc		
	非交互式登录shell进程：
			1.非交互场景
		    	-u USERNAME执行的登录切换，su -u USERNAME；；
		    	图形界面下打开的终端；
			    运行脚本
			2.配置文件搜索路径
			  ~/.bashrc --> /etc/bashrc --> /etc/profile.d/*
	两类配置文件：
		profile类：为交互式登录的shell进程提供配置
			profile类：
				全局：对所有用户都生效；
					/etc/profile 
					/etc/profile.d/*.sh
					
				用户个人：仅对当前用户有效；
					~/.bash_profile
					
				功用：
					1、用于定义环境变量；
					2、运行命令或脚本；
					
		bashrc类：为非交互式登录的shell进程提供配置			
			bashrc类：
				全局：
					/etc/bashrc 
				用户个人：
					~/.bashrc
	
				功用：
					1、定义本地变量；
					2、定义命令别名；
					
			注意：仅管理员可修改全局配置文件；
			
	
	命令行中定义的特性，例如变量和别名作用域为当前shell进程的生命周期；
	
	配置文件定义的特性，只对随后新启动的shell进程有效；
			
	让通过配置文件定义的特性立即生效：
		(1) 通过命令行重复定义一次；
		(2) 让shell进程重读配置文件；
			~]# source /PATH/FROM/CONF_FILE
			~]# .  /PATH/FROM/CONF_FILE
```
---------------------------------------------------------------------
**printf：默认没有换行符**

---------------------------------------------------------------------
**echo：文本输出命令，默认有换行符**
```bash
常用选项：
     -n：不进行换行
     -e:如果需要打印换行，则要加上-e表示启用转义符.
      Eg>1.echo -e "I love \n dinghaha"
        >2.字符串切片
         #替换部分文本
         var="This is a line of text."
          echo ${var/line/REPLACED}
         #替换字符串，从字符串的起始位置和长度来生成子串,length不给默认到结尾，start_pos为负数表示反向,此时长度不给的话表示一个字符
         #${var:start_pos:length}
         echo ${var:(-1)}
         echo ${var:(-1):2}
       >3.引号
        单引号：强引用，变量引用不执行替换
        双引号：弱引用，变量引用会被替换
```
---------------------------------------------------------------------
**set：脚本调试**
```bash
实例脚本：
    1.只会打印set之间的调试信息
     for i in {1..6}
     do
     	set -x
     	echo $i
     	set +x
     done

     echo "script executed"

     echo "user defined debug"

    2.在shell中:表示什么都不做
     function DEBUG()
     {
     	 [ "$_DEBUG" == "on" ] && $@ ||:
     }

     for i in {1..6}
     do
     	DEBUG echo $i
     done

    3.在shebang第一行后面添加一个 -xv参数
     func()
     {
     	#打印第一个参数，第二个参数
     	echo $1,$2;
     	#以列表的方式一次性打印所有参数
     	echo "$@";
     	#类似$@，但是参数被作为单个实体
     echo "$*";
     #命令的返回值
     echo "$?";
     return 0;
     }
```
---------------------------------------------------------------------
**read：交互**
```bash
常用选项：
    read：shell脚本内可以实现交互式的操作      
    read -p “提示”       
    -t：时间限制
      Eg>read -t 2 var
    -n:表示字符数
      Eg>输入中读取n(如下面的3，表示读取3个)个字符
         read -n 3 var
    -p:表示提示
    -s:表示不回显，输入密码有用
      Eg>混合使用,输入密码
         read -s -p "Enter input:" var
实例脚本：
    1.命令行输入
     Eg>read -p "Enter number:" no
     read -p "Enter name:" name
     echo You have entered $no,$
```
---------------------------------------------------------------------
